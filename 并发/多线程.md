---
typora-copy-images-to: pic
typora-root-url: pic
---

## 线程基础

### 线程基础

在操作java多线程的时候必然会遇到锁的问题，在锁的问题中，线程会首先进入一个所谓的Entry Set的集合中，然后尝试去征用锁，征用到锁的就是他的owner，没有征用到，调用wait()，那么就进入Wait Set的区域中，使用完后，锁被释放，调用notfiy或notifyAll欢迎Wait Set区域的内容重新尝试，和Entry Set里面的信息一起征用；调用sleep是没有锁的；synchronized是系统级别的锁；notify是唤醒一个Wait Set区域的等待线程，而notifyAll是唤醒所有相关的线程，join是当前线程会等待对应的几个线程执行完再向下走；Daemon设置为true设置为后台线程，指：主线程执行完后，后台线程自动完成，否则不会；yield是当前让出一个CPU的时间，给其他线程来做，但是让多久，谁也不知道，要知道让多久，sleep知道。

![image-20200713013109502](/image-20200713013109502.png)

#### 线程状态转换图

<img src="/线程状态转换图.png" alt="image-20200618013729569" style="zoom:80%;" />

### 线程创建与运行

线程创建有两种方法

方法一：**继承Tread类**

- 自己创建一个类，继承Tread类，重写run方法（线程需要执行的操作）

- 运行时需要执行类的start方法，如果执行run方法相当于只执行这个run方法，并不能起到创建一个线程去执行的效果

- ```java
  class myThread extends Thread{
      private static int sum = 0;
      private String name;
      
      public myThread(String name){
          this.name = name;
          sum++;
      }
      public void run(){
          System.out.println("这是第"+sum+"个线程");
          System.out.println("name:"+name+" 子线程ID:"+Thread.currentThread().getId());
      }
  }
  
  public class juc_test_1 {
      public static void main(String[] args) {
          myThread myThread = new myThread();
          myThread.start();
      }
  }
  ```

- ```java
  public class juc_test_1 {
      public static void main(String[] args) {
          Thread t =new Thread(){
              public void run(){
                  System.out.println(" 子线程ID:"+Thread.currentThread().getId());
                  System.out.println("---------------------------------");
              }
          };
          t.start();
          
          // 更加直白的简便方法
          //new Thread(){
          //    public void run(){
          //       System.out.println(" 子线程ID:"+Thread.currentThread().getId());
          //        System.out.println("---------------------------------");
          //    }
          //}.start();
      }
  }
  ```

方法二：**实现Runnable接口**

- 实现接口Runable，类重写run方法与上面一样，但是要注意这种方法必须将实现接口类作为参数传入Thread实例类中，然后运行Thread实例类的start方法。

- 虽然最后都是通过运行Thread类start方法，但是这种方法可以让线程实现类继承别的类，因为java中是单继承的。

- ```java
  class myRunable implements Runnable{
      private  String name;
  
      public myRunable(String name){
          this.name = name;
      }
      @Override
      public void run() {
          System.out.println("name:"+name+" 子线程ID:"+Thread.currentThread().getId());
      }
  }
  
  public class juc_test_2 {
      public static void main(String[] args) {
          myRunable myRunable = new myRunable("test runable");
          Thread thread = new Thread(myRunable);
          thread.start();
          
          // lambda表达式简化版
          //
          // Runnable myRunable = () -> System.out.println(" 子线程ID:"+Thread.currentThread().getId());
          // Thread thread = new Thread(myRunable);
          // thread.start();
          
      }
  }
  ```

### volete

保证数据的**内存可见性**与**禁止指令重排序**：

> 普通情况下每个线程都会有自己的缓存，读取一个数据k=v后把这个值存入线程内部缓存，如果其他线程更新了内存中的值，但是线程因为缓存里面有会默认直接读取缓存里面的数据，并不知道内存中值实际已经发生了变化。变量加了volatile，之后线程就不会在缓存里面存储，每次读取这个值都会去内存里面读，这样值发生了变化就会随时知道。
>
> 对象创建过程有三个步骤：
>
> 1. new开辟空间
> 2. 执行init方法
> 3. 赋值
>
> 如果没有禁止指令重排序可能会导致23步骤互换，假设程序执行了13但是还未执行2，其他流程判断对象已经赋值可用直接拿来使用导致了使用半初始化状态对象。java虚拟机volatile内部使用内存屏障来禁止指令重排序

cpu读取数据流程：先从处理器L1和L2里面依次找，找不到就找所有线程共享的L3缓存，如果还找不到则在主存中去找；如果主存中找到则把数据所存在的行数据（64字节）一起放入所有缓存层级。inter cpu使用**MESI缓存一致性协议**保证缓存可见性，如果MESI不行则直接锁总线

<img src="/cpu读取数据流程.png" alt="image-20200623023558998" style="zoom:80%;" />

### Synchronized

实现原理：

1. java代码层面：Synchronized
2. 字节码层面：monitorenter moniterexit（代码前后自动加上监视器）
3. jvm层面：在代码执行过程中自动对锁进行升级
4. 机器码：lock comxchg 指令

首先看一下一个新的object对象在内存中的布局：

![image-20200623015124067](/对象在内存中的布局.png)

一个Object()对象内存由4部分组成：

1. **markword**对象头
   - 8字节
   - **记录了Synchronized信息**
   - 记录了GC 分代年龄信息
2. 类型指针
   - 4字节（虚拟机默认开启压缩，未开启的话8字节）
   - 用来指向对象属于哪个类（指向方法区的引用）
3. 实例数据
   - 对象内部的变量
4. 对齐
   - 如果对象内存不是8字节的倍数就进行填充

可以得知一**个空的Object对象大小为16字节**

通过代码演示对象头文件中的布局，可以看到对object对象加Synchronized锁后markword部分字节码发生了变化：

```java
public class syngonized {
    public static void main(String[] args) {
        Object object = new Object();
        System.out.println(ClassLayout.parseInstance(object).toPrintable());

        synchronized (object){
            System.out.println(ClassLayout.parseInstance(object).toPrintable());
        }
    }
}

// 运行结果
java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                      VALUE
      0     4        (object header)                  01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                  00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                  e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                       VALUE
      0     4        (object header)                   f8 f7 bb 00 (11111000 11110111 10111011 00000000) (12318712)
      4     4        (object header)                   00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                   e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

```

在java1.5以后对一个对象上Synchronized锁，虚拟机内部会根据代码情况自动对锁进行升级，锁状态不可逆，4种锁从轻到重分别为：

1. 无锁

2. 偏向锁

   - 当第一个程申请Synchronized的时候，对象头部markword贴上这个线程指针标签，表明当前有线程正在使用。
   - 好处：**避免了大多数情况下只有单个线程访问的时候向操作系统申请锁**（操作系统锁很重量级，需要**程序-用户态-内核态**申请重量级锁）

3. 轻量级锁（自旋锁）

   - 当有第二个线程来申请的时候，发现对象头已经是偏向锁状态（已有一个线程在占用），则把锁升级为自旋锁
   - 自旋的原理就是cas，多个线程不停地cas，类似原地等待一直进行cas操作，直到线程抢到资源（把当前线程指针贴到markword上）

4. 重量级锁

   - 贴上重量级锁指针，其他等待线程进入到锁维护的等待队列

   - 因为自旋会占用cpu，当自旋超过10次或者自旋线程超过cpu的1/2自动升级为重量级锁，**减轻自旋锁的cpu占用**

   <img src="/Synchronized四种锁.png" alt="image-20200623020534308" style="zoom:80%;" />

定义在方法内部（方法是每个线程独栈）的对象会被JVM自动消除锁，因为线程独占所以不存在锁竞争

### 原子性

i++操作内存中分为读取-计算-存储三个步骤，并不是**原子操作**，多线程情况下对同一变量操作可能会出现问题。

`java.concurrent.atomic` 包提供了原子变量，实现原理：

1. 用volatile来保证变量的内存可见性

2. 用CAS（Compare-And-Swap）算法来保证原子性

   - 原理：读取一个数值的时候先**存储读取时的原值**；然后进行**计算**；写入时**再次读取内存里面这个数的值和读取时存储的值进行比较是否相同，相同则写入**。
   - 可能出现**ABA问题**，解决办法：**加版本号**

   <img src="/CAS原理图.png" alt="image-20200623010258452" style="zoom:50%;" />

`java.concurrent.atomic` 下类保证原子性代码跟踪，以`java.concurrent.atomic.AtomicInteger`为例：

```java
// java.concurrent.atomic.AtomicInteger 类中的getAndSet方法
public final int getAndSet(int newValue) {
    return unsafe.getAndSetInt(this, valueOffset, newValue);
}


// unsafe.class 类下的getAndSetInt实现
// 可以看到调用了compareAndSwapInt方法
public final int getAndSetInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var4));
    return var5;
}
// native方法
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

可以看到这里调用到了native方法，其实继续跟踪下去在虚拟机汇编语言层面就是一句指令：

```asm
lock cmpxchg 指令
```

lock表示有多个cpu时进行加锁，cmpxchg就是Compare&Change的意思

### 四种引用类型应用

#### 弱引用

`ThreadLocal`是表示线程变量，内部实现是采用map形式，map中存放的是一个个entry格式键值对，其中key为指向当前`ThreadLocal`的弱引用。这样的目的是为了防止当线程不存在后如果这里是强引用那么这个`ThreadLocal`永远都不会被回收。

<img src="/弱引用在ThreadLocal中的应用.png" alt="image-20200624012248387" style="zoom: 67%;" />

#### 虚引用

用于管理堆外内存，当指向堆外内存的对象DirectByteBuffer被回收时，需要一个虚引用起到通知的作用，将对象加入队列，之后对堆外内存中的内容进行删除。

<img src="/虚引用管理堆外内存.png" alt="image-20200624012504310" style="zoom:67%;" />

## 锁

### Lock

相比于Synchronized锁，在使用时需要显式地获取和释放锁，少了隐式获取释放锁的便捷性，但是却拥有了**锁获取与释放的可操作性**、**可中断的获取锁**以 及**超时获取锁**等多种synchronized关键字所不具备的同步特性。

`Lock` 实现提供了使用 `synchronized` 方法和语句所没有的其他功能，包括提供了一个非块结构的获取锁尝试 `tryLock()`、一个获取可中断锁的尝试 `lockInterruptibly()`和一个获取超时失效锁的尝试`tryLock(long, TimeUnit)`。

```java
class Run2 implements Runnable{
	private Lock lock=new ReentrantLock();
	private Condition con1=lock.newCondition();
	@Override
	public void run() {
		while (true) {
			lock.lock();
			try {
				while (t.getNum()<=0) {
					con1.await();// 调用此方法阻塞当前线程，并且释放锁
				}
                con1.signalAll();// 唤醒所有的被阻塞线程
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} finally {
				lock.unlock();
			}
		}
	}
}
```

​    在finally中释放锁是为了保证在获取锁以后能够释放锁，也不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放，必须保证return语句发生在try子句中，确保unlock()不会过早发生，将数据暴露给第二个任务。

Lock接口大体结构：

```java
public interface Lock {
	// 获取锁，若获取失败则进行等待
    void lock();
    
    // 可中断锁
    void lockInterruptibly() throws InterruptedException;
    
    // 获取锁，立即返回，成功返回true，否则false
    boolean tryLock();
    
    // 获取锁，若获取失败则在指定时间内等待，成功返回true，否则false
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    
    // 释放锁
    void unlock();
    
    // 新建条件，可用与高级应用
    Condition newCondition();
}
```

### ReentrantLock

ReentrantLock是Lock接口的**唯一实现类**，是一个**可重入锁**，分为**公平锁**和**非公平锁**，二者的区别就在获取锁机会是否和排队顺序相关。

<img src="/ReentrantLock类结构图.png" alt="image-20200627021153442" style="zoom:50%;" />

<img src="/AQS类结构图.png" alt="image-20200627133857909" style="zoom: 80%;" />

`Lock()`方法源码解读：

![image-20200627133113883](/AQS方法调用.png)

`AbstractQueuedSynchronizer`会把所有的请求线程构成一个CLH变量，当一个线程执行完毕`lock.unlock()`时会激活自己的后继中断，但正在执行的线程并不在其中，而那些等待执行的线程全部处于中断状态，线程的显式样式是通过调用`LockSupport.park(()))`完成，而`LockSupport.park()`则调用`sun.misc.Unsafe.park()`本地方法，再进一步，HotSpot在Linux中中通过调用`pthread_mutex_lock`函数把线程交给系统内核进行中断。

```java
public void lock() {
        sync.lock(); // 调用静态内部类sync的lock方法，这里具体有公平锁和非公平锁两种实现
}

// 非公平锁静态内部类sync的lock实现
final void lock() {
    if (compareAndSetState(0, 1)) // 通过CAS设置状态，设置成功那么直接获取锁，反之调用acquire(1)进入同步队列中
        setExclusiveOwnerThread(Thread.currentThread()); // 该方法作用是为锁设置独占线程，其实也就是一个赋值操作
    else
        acquire(1);
}

// 公平锁静态内部类sync的lock实现
final void lock() {
    //调用了AQS的acquire函数,这是关键函数之一
    acquire(1);
}
```

可以看到不管是公平锁还是非公平锁，核心都是acquire方法；

若`tryAcquire`失败并且`acquireQueued`返回true中断标识的话，将会中断当前线程。

**tryAcquire方法**：判断锁的`state`值，若当前未有其他线程持有该锁，则执行`CAS`操作，成功后则设置独占线程；若发现该锁已被线程持有，则判断持有线程是不是当前线程，若是则允许重入，并判断重入的次数是否超过限制，重入成功后修改`state`并返回一个true布尔值。

**`acquireQueued`和`addWaiter`方法**：`addWaiter`方法将当前线程作为一个节点`Node`加入的CLH队列，成功加入队列后，会判断是否有资格去竞争获取锁，有则尝试获取锁，成功后会返回标志位。如果没有资格，则判断是否可以被阻塞，并做相关操作。`acquireQueued`的主要作用是把已经追加到队列的线程节点（addWaiter方法返回值）进行阻塞，但阻塞前又通过`tryAccquire`重试是否能获得锁，如果重试成功能则无需阻塞，直接返回。

```java
public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState(); // 获取State值
    // State == 0表明未被线程持有，CAS方法独占
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // State != 0，检查锁线程是否未自身，是则重入State+1
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}


// ------------------------------------------------------------------------------------------------------------------------------

final boolean acquireQueued(final Node node, int arg) {
    //失败标志
    boolean failed = true;
    try {
        //是否中断标志
        boolean interrupted = false;
        for (;;) {
            //获取前置节点
            final Node p = node.predecessor();
            //如果前置节点为首节点，并且当前线程能够成功获取锁
            if (p == head && tryAcquire(arg)) {
                //将当前节点设置为首节点
                setHead(node);
                p.next = null; //help GC，前首节点出队，帮助GC 
                failed = false;
                return interrupted;
            }
            //判断是否可以阻塞线程并做相应操作，下面具体阅读这几个方法
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        //判断是否获取失败
        if (failed)
            cancelAcquire(node);
    }
}


private Node addWaiter(Node mode) {
    //封装成node
    Node node = new Node(Thread.currentThread(), mode);
    // 获取队列尾节点（作为当前节点的前置节点）
    Node pred = tail;
    //如果尾节点不为空
    if (pred != null) {
        //设置当前节点的前置节点
        node.prev = pred;
        //CAS操作，设置队列尾部
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    //尾节点为null，调用enq方法
    enq(node);
    //返回当前节点
    return node;
}

 private Node enq(final Node node) {
    
    for (;;) {
        Node t = tail;
        //尾节点为null
        if (t == null) { // Must initialize
            //通过CAS操作设置首节点
            if (compareAndSetHead(new Node()))
                //将首节点赋值给尾节点（初始化）
                tail = head;
        } else {
            //设置当前节点的前置节点
            node.prev = t;
            //通过CAS操作设置尾节点
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}

private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    //获取前置节点的等待状态
    int ws = pred.waitStatus;
    //如果为SIGNAL
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        //只有当前置节点的状态位SIGNAL的话，当前节点才能进入阻塞，并等待前置节点的唤醒
        return true;
    if (ws > 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        //如果前置节点为取消状态，则不断往前搜索并找到SIGNAL状态的节点，并加在其后面
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        //通过CAS操作设置前置节点的等待状态位SIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}

/**
 * 如果上面的方法调用返回true，则代表当前节点可以进入阻塞/等待
 */
private final boolean parkAndCheckInterrupt() {
    //通过LockSupport类的park方法来阻塞当前线程
    LockSupport.park(this);
    //被唤醒后，返回中断标志
    return Thread.interrupted();
}  

/**
 * 这里的阻塞具体实现是JVM虚拟机的本地实现，有兴趣者可以自行研究
 */
public static void park(Object blocker) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker);
    UNSAFE.park(false, 0L);
    setBlocker(t, null);
}
```

release() 方法源码：

```java
① 解锁
public void unlock() {
    sync.release(1);
}

② 释放锁
public final boolean release(int arg) {
    //判断是否释放成功
    if (tryRelease(arg)) {
        Node h = head;
        //判断CLH队列的首节点是否为null，并判断等待状态是否正常
        if (h != null && h.waitStatus != 0)
            //唤醒节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}

③ 释放锁，并唤醒CLH队列中的合法首节点
protected final boolean tryRelease(int releases) {
    //计算state和释放数量的差值
    int c = getState() - releases;
    //判断线程是否是锁持有者
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    //初始化释放结果
    boolean free = false;
    //如果当前线程未重入，释放成功
    if (c == 0) {
        free = true;
        //释放锁持有的线程
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}

④ 唤醒阻塞/等待的节点
private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    //获取节点等待状态
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    //获取后置节点
    Node s = node.next;
    //后置节点为null或者为取消状态
    if (s == null || s.waitStatus > 0) {
        s = null;
        //从尾部向前获取到一个不为null且状态不是取消的节点
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    //唤醒该节点
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

总体来讲线程获取锁要经历以下过程(非公平)：    

1. 调用lock方法，会先进行cas操作看下可否设置同步状态1成功，如果成功执行临界区代码    
2. 如果不成功获取同步状态，如果状态是0那么cas设置为1.    
3. 如果同步状态既不是0也不是自身线程持有会把当前线程构造成一个节点。    
4. 把当前线程节点CAS的方式放入队列中，行为上线程阻塞，内部自旋获
5. 取状态。  
6. 线程释放锁，唤醒队列第一个节点，参与竞争。重复上述。

参考目录：

> [[锁机制 part 3 加锁的原理 (Lock.lock)](http://www.blogjava.net/xylz/archive/2010/07/07/325410.html)](http://www.blogjava.net/xylz/archive/2010/07/07/325410.html)
>
> [[锁机制 part 4 锁释放与条件变量 (Lock.unlock And Condition)](http://www.blogjava.net/xylz/archive/2010/07/08/325540.html)](http://www.blogjava.net/xylz/archive/2010/07/08/325540.html)
>
> [Java源码阅读之ReentrantLock - lock和unLock方法](https://www.jianshu.com/p/fc16ee7ccffa)
>
> [Java锁Lock源码分析（一）](https://blog.csdn.net/mayongzhan_csdn/article/details/79374996)

### AQS

其实上面ReentrantLock已经分析了公平锁和非公平锁的AQS实现原理，总结一下，AQS的基本思想就是一个同步器，提供了两种操作：

- **获取锁**
  - 首先判断当前状态是否允许获取锁，如果是就获取锁，否则就阻塞操作或者获取失败，也就是说如果是独占锁就可能阻塞，如果是共享锁就可能失败。另外如果是阻塞线程，那么线程就需要进入阻塞队列。当状态位允许获取锁时就修改状态，并且如果进了队列就从队列中移除。
- **释放锁**
  - 这个过程就是修改状态位，如果有线程因为状态位阻塞的话就唤醒队列中的一个或者更多线程。

需要三个条件：

- **原子性操作同步器的状态位**
- **阻塞和唤醒线程**
- **一个有序的队列**
  - 在AQS中采用CHL列表（FIFO）来解决有序的队列的问题。
  - 入队列(*enqueue)：*采用CAS操作，每次比较尾结点是否一致，然后插入的到尾结点中。
  - 出队列(*dequeue*):由于每一个节点也缓存了一个状态，决定是否出队列，因此当不满足条件时就需要自旋等待，一旦满足条件就将头结点设置为下一个节点。

AQS重要属性属性：

- *private volatile int state*

- *private transient volatile Node head*

- *private transient volatile Node tail*

- 其中state描述的有多少个线程取得了锁，对于互斥锁来说state<=1。head/tail加上CAS操作就构成了一个CHL的FIFO队列。下面是Node节点的属性：

  - ***volatile int waitStatus;\*** 节点的等待状态，一个节点可能位于以下几种状态：
    - CANCELLED = 1： 节点操作因为超时或者对应的线程被interrupt。节点不应该留在此状态，一旦达到此状态将从CHL队列中踢出。
    - SIGNAL = -1： 节点的继任节点是（或者将要成为）BLOCKED状态（例如通过LockSupport.park()操作），因此一个节点一旦被释放（解锁）或者取消就需要唤醒（LockSupport.unpack()）它的继任节点。
    - CONDITION = -2：表明节点对应的线程因为不满足一个条件（Condition）而被阻塞。
    - 0： 正常状态，新生的非CONDITION节点都是此状态。
    - 非负值标识节点不需要被通知（唤醒）。
- ***volatile Node prev;***此节点的前一个节点。节点的waitStatus依赖于前一个节点的状态。
  - ***volatile Node next;***此节点的后一个节点。后一个节点是否被唤醒（uppark()）依赖于当前节点是否被释放。
  - ***volatile Thread thread;***节点绑定的线程。
  - ***Node nextWaiter;\***下一个等待条件（Condition）的节点，由于Condition是独占模式，因此这里有一个简单的队列来描述Condition上的线程节点。

**AQS中还有一个表示状态的字段state，例如ReentrantLocky用它表示线程重入锁的次数，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性**。

### Condition

Condition的本质就是等待队列和同步队列的交互

当一个持有锁的线程调用Condition.await()时，它会执行以下步骤：

1. 构造一个新的***Condition*的FIFO等待队列**节点加入到等待队列队尾
2. 释放锁，也就是将它的同步队列节点从同步队列队首移除
3. 自旋，直到它在等待队列上的节点移动到了同步队列（通过其他线程调用signal()）或被中断
4. 阻塞当前节点，直到它获取到了锁，也就是它在同步队列上的节点排队排到了队首，并将自己从*Condition*的FIFO队列中释放。

当一个持有锁的线程调用Condition.signal()时，它会执行以下操作：

从等待队列的队首开始，尝试对队首节点执行唤醒操作；如果节点CANCELLED，就尝试唤醒下一个节点；如果再CANCELLED则继续迭代。

对每个节点执行唤醒操作时，首先将节点加入同步队列，此时await()操作的步骤3的解锁条件就已经开启了。然后分两种情况讨论：

1. 如果先驱节点的状态为CANCELLED(>0) 或设置先驱节点的状态为SIGNAL失败，那么就立即唤醒当前节点对应的线程，此时await()方法就会完成步骤3，进入步骤4.
2. 如果成功把先驱节点的状态设置为了SIGNAL，那么就不立即唤醒了。等到先驱节点成为同步队列首节点并释放了同步状态后，会自动唤醒当前节点对应线程的，这时候await()的步骤3才执行完成，而且有很大概率快速完成步骤4.



以下是对等待队列是单向队列、同步队列是双向队列的一些思考，欢迎提出不同意见：

*之所以同步队列要设计成双向的，是因为在同步队列中，节点唤醒是接力式的，由每一个节点唤醒它的下一个节点，如果是由next指针获取下一个节点，是有可能获取失败的，因为虚拟队列每添加一个节点，是先用CAS把tail设置为新节点，然后才修改原tail的next指针到新节点的。因此用next向后遍历是不安全的，但是如果在设置新节点为tail前，为新节点设置prev，则可以保证从tail往前遍历是安全的。因此要安全的获取一个节点Node的下一个节点，先要看next是不是null，如果是null，还要从tail往前遍历看看能不能遍历到Node。*

*而等待队列就简单多了，等待的线程就是等待者，只负责等待，唤醒的线程就是唤醒者，只负责唤醒，因此每次要执行唤醒操作的时候，直接唤醒等待队列的首节点就行了。等待队列的实现中不需要遍历队列，因此也不需要prev指针。*



### 闭锁**（Latch）**

一种同步方法，可以延迟线程的进度直到线程到达某个终点状态。通俗的讲就是，一个闭锁相当于一扇大门，在大门打开之前所有线程都被阻断，一旦大门打开所有线程都将通过，但是一旦大门打开，所有线程都通过了，那么这个闭锁的状态就失效了，门的状态也就不能变了，只能是打开状态。也就是说闭锁的状态是一次性的，它**确保在闭锁打开之前所有特定的活动都需要在闭锁打开之后才能完成**。

CountDownLatch主要方法有两个：**await()**  和  **countDown()**。还有构造器以及内部类syn以及父类，由于他的内部是继承自AQS，AbstractQueueSynchronizer。利用了AQS内部状态state变量记录等待队列的长度，CountDownLatch的**节点状态则由AQS的Node节点提供**。

**await()方法**：

> **将当前线程加入CountDownLatch的等待队列**中，并且设置装载了线程的Node容器的状态。然后每次停靠都要确认队列中线程状态如何，以确保安全。

**countDown()方法**：

> **将await()方法中断停靠的线程全部激活释放**，让其继续运行。
>
> 自旋cas去改变我们初始化节点时候的状态值state，将其**设置为0**，注意这里cas的实现导致只有一个线程能拿到true，因此也只有一个线程去执行“释放”

参考目录：

> [java并发笔记之闭锁源码解读](https://blog.csdn.net/m0_37590135/article/details/102143990)



### CyclicBarrier

![image-20200627160708060](/CyclicBarrier示意图.png)

翻译为栅栏，用于将多个线程等待在某个位置，**所有线程都准备好之后，全部同时执行**；它的一个特点就是可**以循环使用**(Cyclic)。代码原理：

1. 线程通过ReentrantLock对象同步调用栅栏对象的dowait()方法；
2. 通过count数计算当前等待的线程数量，若当前线程是最后一个等待线程(最后一个到达栅栏的线程)，则由该线程执行栅栏任务（barrierAction）；
3. 若当前线程不是最后一个到达栅栏的线程，则会把当前线程包装成一个满足等待条件的node，并放入等待条件队列；
4. 释放重入锁，便于其他线程调用栅栏的dowait()。

与CounDownLatch的区别：

- CountDownLatch是线程间的等待，是当**前面N个线程全部执行完，第n+1的线程才可以执行**！且CountDownLatch只能使用一次；
- CyclicBarrier是线程内的等待，是当**N个线程都执行到一个栅栏状态时，我N个线程才会继续执行**！CyclicBarrier可以循环使用；

参考目录：

> [实战java高并发程序设计之CyclicBarrier源码分析](https://blog.csdn.net/nobody_1/article/details/83021048)
>
> [[JAVA并发编程JUC之CyclicBarrier源码分析](https://www.cnblogs.com/autumnlight/p/12107678.html)](https://www.cnblogs.com/autumnlight/p/12107678.html)



### Semaphore

计数信号量，它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。

Semaphore的实现方式和CountDownLatch非常相似，基于AQS做了一些定制。**通过维持AQS的锁全局计数state字段来实现定量锁的加锁和解锁操作**。

Acquire()获取锁方法：

- 当前线程调用该方法的时候，目的是希望获取一个信号量资源，如果当前信号量计数个数大于 0 ，并且当前线程获取到了一个信号量则该方法直接返回，当前信号量的计数会减少 1 。否则会被放入AQS的阻塞队列，当前线程被挂起，直到其他线程调用了release方法释放了信号量，并且当前线程通过竞争获取到了改信号量。当前线程被其他线程调用了 interrupte（）方法中断后，当前线程会抛出 InterruptedException异常返回。源码如下：

```java
    public void acquire() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }


    public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) < 0)
            doAcquireSharedInterruptibly(arg);
    }


    protected int tryAcquireShared(int acquires) {
        for (;;) {
            if (hasQueuedPredecessors())
                return -1;
            // 通过递减锁全局技术变量state来判定是否能获取锁
            // 值小于0说明获锁失败，否则代表获锁成功
            int available = getState();
            int remaining = available - acquires;
            if (remaining < 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        }
    }


    private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

release()释放锁方法：

```java
    public void release() {
        sync.releaseShared(1);
    }


    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }


    protected final boolean tryReleaseShared(int releases) {
        for (;;) {
            // 释放锁，通过累加全局计数state来实现
            int current = getState();
            int next = current + releases;
            if (next < current) // overflow
                throw new Error("Maximum permit count exceeded");
            if (compareAndSetState(current, next))
                return true;
        }
    }


    private void doReleaseShared() {
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    unparkSuccessor(h);
                }
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }
```

### ReentrantReadWriteLock

读写锁：

1. 申请读锁。当没有其他写锁占有，或者读锁在队列中排队时间最长的，才能成功
2. 申请写锁。当没有其他线程占有读/写锁的情况下，才能成功

类结构与`ReentrantLock`差不多，加锁释放锁的逻辑也差不多，不同的是它还多了**ReadLock**内部类和**WriteLock**内部类，以及读写对应的成员变量和方法。并且少了lock()、unlock()等方法，而是把加锁解锁的功能下方给这两个子类，符合ReadWriteLock接口的定义，内部的AQS抽象类具体State判定方法有点差别。

而ReentrantReadWriteLock 则需要维护读状态和写状态，一个state是无法表示写和读状态的。ReentrantReadWriteLock 巧妙的使用 state 的高 16 位表示读状态，

也就是获取改读锁的线程个数，低 16 位 表示获取到写锁的线程的可重入次数。并通过CAS对其进行操作实现了读写分离，在读多写少的场景下比较适用。

**加锁过程：**

```java
    public static class WriteLock implements Lock, java.io.Serializable {
        private static final long serialVersionUID = -4992448646407690164L;
        private final Sync sync;

        protected WriteLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
        }

        public void lock() {
            sync.acquire(1);
        }
    }

    public final void acquire(int arg) {
        // 1、先尝试获取锁tryAcquire
        // 2、获锁失败就addWaiter操作
        // 3、acquireQueued判断是否唤醒
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }

    protected final boolean tryAcquire(int acquires) {
            Thread current = Thread.currentThread();
            // 获取锁状态state变量
            int c = getState();
            // 获取写锁占用的计数，State的低16位
            int w = exclusiveCount(c);
            // 如果锁状态state不为0，表示有读锁或者写锁
            if (c != 0) {
                // 1、当前state不为0，如果写锁状态为0说明读锁此时被占用，说明锁被读锁占用
                // 2、锁状态state不为空且占锁线程为当前线程（属于锁重入），说明锁被其他线程占用
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                // 写锁重入数溢出
                if (w + exclusiveCount(acquires) > MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                // 写锁获取成功返回成功标记
                setState(c + acquires);
                return true;
            }
            // 如果写锁阻塞 或者 设置state状态失败，那么就代表获锁失败
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            // 设置当前锁占用线程为当前线程
            setExclusiveOwnerThread(current);
            return true;
        }
```

参考目录：

> [[Java并发编程笔记之读写锁 ReentrantReadWriteLock 源码分析](https://www.cnblogs.com/huangjuncong/p/9183761.html)](https://www.cnblogs.com/huangjuncong/p/9183761.html)

## 并发容器

### **ConcurrentHshMap**

HashMap线程不安全，HashTable线程安全但是效率低（有锁，锁的单位是整个表）。

> - **HashMap线程不安全**：多线程情况下使用HashMap进行put操作会引起get操作死循环。因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry（死循环原理详见[http://www.importnew.com/22011.html](https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Fwww.importnew.com%2F22011.html)），也可能造成数据丢失。
> - **效率低下的HashTable**：HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable 的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同 步方法时，会进入阻塞或轮询状态。**如线程1使用put进行元素添加，线程2不但不能使用put方 法添加元素，也不能使用get方法来获取元素**，所以竞争越激烈效率越低。

ConcurrentHashMap采用锁分段技术：因为HashTable效率低下的原因是因为每次都锁整个表，那么我们只要让每次锁只锁表里面的部分数据就行了。将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

JDK7中的分段锁实现：

> ConcurrentHashMap**由Segment数组结构和HashEntry数组结构组成**，Segment是一个可重入锁（Segment继承了ReentrantLock），HashEntry用于存储Entry键值对。一个ConcurrentHashMap里包含一个Segment数组，一个Segment里包含（用“锁住”或许更合适）一个HashEntry数组，每个HashEntry数组中的元素是一个链表结构的元素，HashEntry中的value以及next都被volatile修饰。
>
> oncurrentHashMap默认的并发度为16（也就是说默认Segment数组长度为16），设置过大会导致本来位于同一个Segment中的访问扩散到不同的Segment，导致cpu cache命中降低。
>
> JDK7中除了第一个Segment之外，剩余的Segments采用的是延迟初始化的机制：每次put之前都需要检查key对应的Segment是否为null，如果是则调用ensureSegment()以确保对应的Segment被创建。

JDK8中的分段锁实现：

> java8实现了粒度更细的加锁，去掉了segment数组，**直接使用synchronized锁住**hash后得到的**数组下标位置中的第一个元素** 。另外，在java8中，当链表内的node数量满足一定条件时，链表会变成红黑树，加快搜索速度。
>
> <img src="/JDK7于JDK8分段锁实现.png" alt="image-20200626133857010" style="zoom: 50%;" />
>
> - 默认数组大小为16
> - 扩容因子为0.75，扩容后数组大小翻倍
> - 当存储的node总数量 >= 数组长度*扩容因子时，会进行扩容（数组中的元素、链表元素、红黑树元素都是内部类Node的实例或子类实例，这里的node总数量是指所有put进map的node数量）
> - 当链表长度>=8且数组长度<64时会进行扩容
> - 当数组下是链表时，在扩容的时候会从链表的尾部开始rehash
> - 当链表长度>=8且数组长度>=64时链表会变成红黑树
> - 树节点减少直至为空时会将对应的数组下标置空，下次存储操作再定位在这个下标t时会按照链表存储
> - 扩容时树节点数量<=6时会变成链表
> - 当一个事物操作发现map正在扩容时，会帮助扩容
> - map正在扩容时获取（get等类似操作）操作还没进行扩容的下标会从原来的table获取，扩容完毕的下标会从新的table中获取
>
> put方法会首先检查table有没有初始化，没有则初始化table，定位到下标后如果下标内是代表rehash的特殊node，则会帮助扩容，否则进行更新或插入。如果链表数量达到条件则会变为红黑树。在最后增加map的总node数量时，若总数超过table长度的0.75倍则会进行扩容，扩容时会将下标倒序分为几块任务，可由其余线程帮助完成扩容。
>
> get时会根据key定位到下标，然后遍历链表或数组查找对应的node，如果下标内是代表rehash的特殊node，则会去临时扩容table内查询数据
>
> remove时会根据下标遍历下标内的链表或者红黑树，如果下标内是代表rehash的特殊node，则会帮组扩容
>
> get()方法逻辑：
>
> ```java
>  public V get(Object key) {
>      计算hash值
>      if table!=null && hash值对应数组节点!=null:
>      	if 数组下标第一个node匹配：
>             return node
>         else if 第一个node的hash小于0：
>             表明是红黑树或者ForwardingNode，调用各自find方法
>             return node
>         都不是则表明是链表，遍历链表
>         return node
>  }
> ```
>
> put()方法逻辑：
>
> ```java
> public V put(K key, V value) {
>     if (key && value) is null:
>     	return error
>     compute key hash
>     if table is null:
>     	init table //使用cas策略锁住table size长度防止重复初始化
>     else if first node is null:
>     	node = k-v
>         break
>     else if first node hash == -1:  // 表明对应桶正在rehash扩容
>     	帮助扩容
>     else:
>     	synchronized(first node)  //锁住第一个node
>             if 链表：
>                 遍历链表，存在key则更新，不存在则添加到末尾
>             else if 红黑树：
>                 node加入红黑树
>                 
>     添加node后判断table总长度，超过阈值进行rehash扩容，如果数组长度超过64则链表转红黑树（锁第一个node保证并发安全）
> }
> 
> ```
>
> rehash扩容原理：
>
> **多个进程同时扩容使用扩容桶边界transferIndex属性实现**，一开始这个transferIndex 在数组的最右边 。此时有一个线程发现已经到达扩容阈值，准备开始扩容，此时左移transferIndex （CAS），每次至少左移16个大小，也就是说**单个线程至少迁移16个桶**，**按照降序挨个迁移**，**迁移过程中单个桶在新表里面分配为两个桶**。迁移过后桶替换为ForwardingNode节点，表明该桶已经扩容完毕，且查找时利用此节点的find方法在新table里面进行查找。
>
> [JDK8 concurrentHashMap源码分析](https://blog.csdn.net/ddxd0406/article/details/81389583)

### ConcurrentLinkedQueue

Queue的一个线程安全实现，一个基于链接节点的**无界**线程安全队列，**FIFO（先进先出）**，元素不允许为null。基于CAS的“wait－free”（常规无等待）来实现。

ConcurrentLinkedQueue是由head节点和tail节点组成，每个节点有节点元素item和指向下一个节点的next的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。

ConcurrentLinkedQueue 的非阻塞算法实现主要可概括为下面几点:

> 1. **使用 CAS 原子指令来处理对数据的并发访问**，这是非阻塞算法得以实现的基础。
> 2. **head/tail 并非总是指向队列的头 / 尾节点**，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。**这是非阻塞算法得以实现的关键。**
> 3. 以批处理方式来更新head/tail，从整体上减少入队 / 出队操作的开销。

入队原理：

> 入队列就是将入队节点添加到队列的尾部，对于先进先出的队列入队所要做的事情就是将**入队节点设置成尾节点**，但是在并发情况下可能有多个线程同时添加，那么**正常想法让tail指针永远指向尾结点使用cas策略即可**。但是这么做有个缺点就是**每次都需要使用循环CAS更新tail指针。如果能减少CAS更新tail指针的次数，就能提高入队的效率。
>
> 实现中不是每次节点入队后都将 tail指针更新成尾节点，只有当**tail指针和尾节点的距离大于等于1时才更新tail**，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，距离越长带来的负面效果就是**每次入队时定位尾节点的时间就越长**（需要通过tail指针向后遍历，判断是**尾结点的标志是节点next为null**），但是这样仍然能提高入队的效率，因为从本质上来看它通过**增加对volatile变量的读操作来减少了对volatile变量的写操作**，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。

出队原理：

> 出队也是类似入队，并不是每次出队都立即更新head指针，而是先弹出头结点元素。当下一次出队检测到head指针指向的头结点中没有元素时弹出下一个节点同时更新head指针，这样更新head指针的次数就缩减了一半，也是为了**减少使用CAS更新head指针的消耗，从而提高出队效率**。
>
> 首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。
>
> [jdk1.8中ConcurrentLinkedQueue的实现原理](https://blog.csdn.net/fjse51/article/details/55511475)
>
> [ConcurrentLinkedQueue 流程源码分析 (基于Java 8)](https://www.jianshu.com/p/08e8b0c424c0)

### 阻塞队列

实现一个线程安全的队列有3种办法：

1. synchronized
   - 就像Vector或者Collections.synchronizedList/Collection，会导致吞吐量急剧下降
2. Lock
   - 使用ReentrantReadWriteLock来代替ReentrantLock提高读取的吞吐量
3. CAS
   - ConcurrentHshMap就是使用的CAS

阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。支持阻塞的插入方法：意思是**当队列满（无界队列除外）时，队列会阻塞插入元素的线程，直到队列不满**。支持阻塞的移除方法：意思是在**队列为空时，获取元素的线程会等待队列变为非空。**

阻塞队列常用于**生产者和消费者的场景**，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。阻塞队列对插入和移除两个附加操作提供了4种处理方式。

![image-20200626184831297](/阻塞队列对插入和移除两个附加操作提供了4种处理方式.png)

1. 抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（"Queuefull"）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。
2. ·返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。
3. ·一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。
4. ·超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。

  注意：如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永 远不会被阻塞，而且使用offer方法时，该方法永远返回true。

**阻塞队列分类**：

1. ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
2. LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
3. PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
4. DelayQueue：一个使用优先级队列实现的无界阻塞队列。
5. SynchronousQueue：一个不存储元素的阻塞队列。
6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

**阻塞队列实现原理**：

> JDK通过**通知模式**实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码 发现**ArrayBlockingQueue使用了Condition来实现。也就是通过await/signal来实现。**

#### LinkedBlockingQueue

和ConcurrentLinkedQueue的结构类似，都是采用头尾节点，每个节点指向下一个节点的结构。引入了原子计数器count，这意味着获取队列大小size()已经是常量时间了，不再需要遍历队列，每次队列长度有变更时只需要修改count即可。入了两个锁，一个**入队列锁**，一个**出队列锁**。



## 线程池

### 线程池基础

线程池状态转换：

![threadpool-status.png](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/threadpool-status.png)

1. **RUNNING** ：能接受新提交的任务，并且也能处理阻塞队列中的任务；

2. **SHUTDOWN**：关闭状态，**不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务**。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；

3. **STOP**：**不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程**。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；

4. **TIDYING**：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。

5. **TERMINATED**：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。

   进入TERMINATED的条件如下：

   - 线程池不是RUNNING状态；
   - 线程池状态不是TIDYING状态或TERMINATED状态；
   - 如果线程池状态是SHUTDOWN并且workerQueue为空；
   - workerCount为0；
   - 设置TIDYING状态成功。

为了应对线程数量很多导致频繁创建销毁线程带来的开销，当单个任务处理时间较短时，引入线程池，线程池类结构图如下：

![QQ20170331-004227.png](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/QQ20170331-004227.png)

**Executor框架接口**

主要提供了将任务提交与执行两个步骤分开的思想。只有一个`execute`方法，用来创建或启动线程。

```java
Thread t = new Thread();
t.start();
//------------------------------------------------
Thread t = new Thread();
executor.execute(t);
```

**ExecutorService接口**

继承自Executor接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。增加了shutDown()，shutDownNow()，invokeAll()，invokeAny()和submit()等方法。如果需要支持即时关闭，也就是shutDownNow()方法，则任务需要正确处理中断。

**ScheduledExecutorService接口**

扩展ExecutorService接口并增加了schedule方法，可以在指定的延时后执行一个Runnable或者Callable任务。

### ThreadPoolExecutor分析

ThreadPoolExecutor继承自AbstractExecutorService，也是实现了ExecutorService接口。

构造方法：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
}
```

- **corePoolSize**：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断：
  - 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；
  - 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务；
  - 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理；
  - 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务；
- **maximumPoolSize**：最大线程数量；
- **workQueue**：阻塞等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:
- **keepAliveTime**：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；
- **threadFactory**：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。
- **handler**：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：



[深入理解Java线程池：ThreadPoolExecutor](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95)

[Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)









