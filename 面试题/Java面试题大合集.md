**JAVA** 

###  **Java并发**：

1.  Java线程池核心参数与工作流程，拒绝策略 107 ✅
2.  volatile关键字的原理与作用 61 ✅
3.  Synchronized和Lock的实现原理与区别 54 
4.  synchronized原理 45 ✅
5.  ConcurrentHashMap原理，如何保证线程安全 44 
6.  Java中创建线程的几种方式 36 ✅
7.  CAS操作原理与实现 32 
8.  AQS实现机制 30 ✅
9.  Threadlocal原理、使用场景、内存泄漏问题 24 ✅
10.  Java中的锁类型，区别以及锁升级 24 
11.  线程的状态及转移 23 ✅
12.  Java如何保证线程安全 21 ✅
13.  悲观锁与乐观锁及其区别 19 ✅
14.  Synchronized锁升级的策略 16 ✅
15.  wait和sleep的区别 14 
16.  如何设置线程池参数 13 ✅
17.  hashmap线程不安全问题 12 
18.  Java中线程同步的方式有哪些？ 11 
19.  volatile与synchronizede的区别？ 11 
20.  RetreenLock原理 10 
21.  线程池的实现原理 8 
22.  synchronized可以锁的内容 8 
23.  ReentrantLock原理 7 
24.  JUC包下常用的类 6 
25.  可重入锁的实现原理 5 
26.  实现多线程的几种方式？ 5 
27.  CountDownLatch原理 5 
28.  公平锁与非公平锁的实现 5 
29.  简述一下JMM 4 
30.  多线程三大特性 4 
31.  简述什么是自旋锁 4 
32.  为什么要用线程池？ 3 
33.  为何缓存分三级而不是两级？ 3 
34.  读写锁实现方式 3 
35.  ArrayList线程安全吗？多线程环境下怎么使用ArrayList？ 3 
36.  java自带的4种线程池 3 ✅
37.  简述线程的私有资源与共享资源 2 
38.  AtomicInteger底层实现 2 
39.  线程池优点，线程池里线程报的异常如何抓取，在线程池外捕获 2 ✅
40.  列举几种阻塞队列并对比分析 2 
41.  wait和notify为什么定义在Object类？ 2 
42.  如何得到线程池的异步处理结果？ 2 
43.  moniter监视器的底层原理 2 
44.  fork/join及countdownlatch区别 2 
45.  线程的start方法与run方法作用 2 
46.  CAS 有哪些参数 2 
47.  线程什么情况下会中断 2 
49.  为什么Synchronized是重量级锁？ 2 
50.  读写并发，若读多写少，如何设计实现？ 2 
51.  线程池一直拒绝线程任务，如何处理？ 1 
52.  sychronized为什么是锁对象而不是锁线程 1 
54.  简述Happen before 原则 1 
55.  线程安全加锁的粒度问题 1 
56.  简述wait与block及其区别 1 
57.  线程间通信 1 
58.  简述如何进行锁粗化 1 
59.  手写线程池 1 
60.  简述什么是内存屏障 1 
61.  为什么不推荐使用Executors创建线程池？ 1 
62.  concurrentHashMap 的size是怎么计算的 1 
63.  Java线程池状态与切换 1 
64.  Thread.sleep(0)的作用 1 
65.  多线程切换需要保存哪些内容 1 
66.  IO密集型程序优化 1 
67.  子线程异常，父线程会如何处理？ 1 
68.  "介绍一下对多线程的理解（宏观理解，并尽量暴露自己熟悉的知识点）" 1 
69.  手写线程安全，大小有限、超时放弃的队列 1 
70.  Thread与Runnable的区别 1 
71.  锁都有哪些实现方式？ 1 
72.  Java并发执行程序的有哪些解决方案？ 1 
73.  单核机器多线程需不需要加锁？ 1 
74.  偏向锁升级为轻量级的锁，如何考虑线程暂停的安全点 1 
75.  定时任务的实现原理 1 
76.  Java的线程和操作系统的线程的区别 1 
77.  线程池的核心线程是否可以被回收，如何回收？ 1 
78.  如何立刻终止线程？ 1 
79.  线程池默认的阻塞队列是什么 1 
80.  callable和runable的区别 1 
81.  Executor，Executors工具类如何进行线程管理 1 
82.  如何实现两个线程交替进行 1 
83.  多线程如何进行参数传递？ 1 
84.  如何主动中断一个线程 1 
85.  Synchronized锁类对象和this的区别 1 
86.  什么是死锁以及排查方式 1 
87.  ConcurrentHashMap get、set都加锁了吗？用的是什么共享变量 1 
88.  CAS如何解决ABA问题 1 
89.  手写多线程的Demo 1 

###  **Java基础** **：** 

1.  类加载机制 47 ✅
2.  ‘==’与equals区别 45 ✅
3.  接口与抽象类的区别 37 ✅
4.  重写和重载的区别 35 
5.  String与StringBuffer，StringBuilder区别 26 ✅
6.  双亲委派机制 24 
7.  Java反射机制 24 ✅
8.  final,finally,finalize区别？finalize作用 21 ✅
9.  深拷贝与浅拷贝区别 19 
10.  final关键字特性 13 
11.  Java基本数据类型 13 
12.  面向对象的三大特征 11 
13.  java的泛型 10 
14.  Object类中的基本方法 10 ✅
15.  Java的强，软，弱，虚引用以及软引用使用场景 9 
16.  多态的实现原理 9 
17.  Java的动态代理 8 
18.  static关键字的功能 8 
19.  try、catch、finally执行顺序 7 
20.  简述Java的封装、继承、多态 7 
21.  Java中的有序性、可见性、原子性的理解 6 
22.  jdk和jre的区别 6 
23.  简述为什么要重写equals和hash方法 6 
24.  简述自动装箱与自动拆箱 6 
25.  简述Java的异常类型 6 
26.  值传递与引用传递的区别 6 
27.  Java中的exception分为哪两类？io异常属于哪一种 5 
28.  hashcode和equals的区别 4 
29.  java 如何实现深拷贝 4 
30.  new一个对象的过程 4 ✅
31.  &和&&的作用与区别 4 
32.  java与c++的区别 3 
33.  说一下函数重载 3 
34.  const关键字作用 3 
35.  varchar和char的区别 3 
36.  重写equals方法的注意点 2 
37.  类继承和接口的共性 2 
38.  static关键字 2 
39.  String为什么是不可变的 2 
40.  Cglib代理 2 
41.  system.arraycopy 是深拷贝吗 2 
42.  Java如何解决循环引用问题 2 
43.  Error和Exception的区别 2 
44.  静态变量和成员变量的区别 2 
45.  notify和notifyall的区别 2 
46.  Java中float或者Double是否可以用来表示金额？ 2 
47.  程序初始化的步骤：static和一般的代码块、方法的执行顺序 2 
48.  jdk代理与cglib代理的区别 2 
49.  对于JavaSE的理解 2 
50.  函数式编程的理解 2 
51.  MD5加密算法的原理 1 
52.  如何自定义类加载的过程 1 
53.  列举String类中的方法 1 
54.  java程序是如何运行起来的？ 1 
55.  public,private,protected,default权限控制的区别 1 
56.  continue与break的区别 1 
57.  Java代码编译方式与程序执行方式 1 
58.  1.0+2.0 != 3.0 的底层原理 1 
59.  内部类与静态类的本质区别（字节码角度） 1 
60.  分析说明泛型擦除 1 
61.  使用private修饰的方法 ，子类是否能够重写 1 
62.  Java中序列化与反序列化作用与使用场景？ 1 
63.  一个对象包含一个int，总共占多大内存？ 1 
64.  Stream实现数组相加 1 
65.  类的对象是在堆上还是在栈上 1 
66.  Java内部类能不能访问外部类私有成员变量 1 
67.  System.arraycopy()、Arrays.copyOf()的区别 1 
68.  简述如何解决Java包冲突 1 
69.  this和super的区别 1 
70.  String可以被继承吗 1 
71.  如何理解Java的跨平台语言特性？ 1 
72.  Java实现对象[排序]()的几种方式 1 
73.  int与long的区别 1 
74.  接口和抽象类是否可以写静态方法 1 
75.  Java中是否可以有同名类 1 
76.  接口是否可用public关键字 1 
77.  四种访问修饰符，对子类、同包、不同包下的可见性 1 
78.  char能存储汉字吗，int的取值范围 1 
79.  怎么让Interface变成FunctionalInterface 1 
80.  Java的类卸载机制 1 
81.  静态代理和动态代理的区别 1 
82.  JDK1.8新特性 1 
83.  Arrays.sort()用的哪种[排序]()[算法]() 1 
84.  Stream的使用 1 

###  **Java容器：** 

1.  hashmap底层原理（数据结构、为什么用[红黑树]()等） 135 
2.  ArrayList与LinkedList区别 57 
3.  Java集合类（线程安全/不安全） 57 
4.  hashmap与concurrenthashmap的区别 21 
5.  HashMap与HashTable区别 21 ✅
6.  HashMap的扩容方式 19 
7.  Arraylist的扩容过程 16 
8.  HashMap1.8比1.7版本对比 14 
9.  Hash碰撞的解决办法 14 
10.  Hashset底层源码分析 12 
11.  List和Set底层继承或实现什么接口（对比map） 10 
12.  hashmap和treeMap的比较 9 
13.  ArrayList底层实现原理 9 
14.  Hashmap put对象时的注意点 8 
15.  简述hashmap的put方法（注意扩容） 6 
16.  linkedHashmap和hashmap比较 6 
17.  Map的几种实现形式与横向对比 5 
18.  如何实现一个hashtable 5 
19.  Set的底层结构 4 
20.  concurrenthashmap 1.8前后有什么区别 4 
21.  简述hashmap为什么不安全 3 
22.  hashmap转换为[红黑树]()的条件 3 
23.  HashMap 的长度为什么是2的幂次方 3 
24.  ArrayList中有16个元素，插入删除操作性能分析 3 
25.  vector的扩容机制 3 
26.  Vector、CopyOnWriteArrayList 用哪个比较好 2 
27.  说明遍历集合的方法 2 
28.  List和Map的区别 2 
29.  手写实现ArrayList 2 
30.  hashmap的长度为什么是2的幂次 2 
31.  ArrayList和LinkedList的使用场景和遍历插入时间复杂度？ 2 
32.  简述Set和Map的区别 1 
33.  ArrayList底层是怎么[排序]()的 1 
34.  hashmap[链表]()加锁的话是否线程安全 1 
35.  LinkedList为什么遍历慢？ 1 
36.  ConcurrentHashMap在哪里使用了CAS 1 
37.  List的实现类有哪些？ 1 
38.  如果单个同的元素数量很大，Map要怎么设计？ 1 
39.  HashMap中整数作为Key，怎么设计比较好？ 1 
40.  手写实现LinkedList 1 
41.  hashmap最大高度是多少？ 1 
42.  HashMap的键值是否可以为空/Null 1 
43.  Entry数组是否可以用[链表]()替代 1 
44.  Hash桶很多但元素少，如何快速遍历？ 1 
45.  hashtable和concurrenthashmap的区别？ 1 
46.  列举CopyOnWriteArrayList的适用场景 1 
47.  PriorityQueue底层数据结构 1 
48.  如何处理hashmap遍历过程中删除元素的特殊情况 1 
49.  HashMap负载因子为什么是0.75？ 1 
50.  Concurrenthashmap如何获取size() 1 
51.  sortset底层数据结构 1 
52.  数组和[链表]()是否可以作为hashmap的key 1 
53.  treeMap为什么要用[红黑树]() 1 
54.  为什么arraylist查询效率高，linkedlist插入效率高 1 
55.  Map中Key为对象的注意点 1 
56.  HashTbale的底层实现原理 1 

 

###  **Java虚拟机：** 

1.  Jvm内存模型 112 
2.  Jvm垃圾回收[算法]() 60 
3.  Jvm垃圾回收器 46 
4.  整体介绍垃圾回收 40 
5.  Jvm调优参数与实例 14 
6.  遇到的OOM问题，如何定位、排查与解决 14 
7.  CMS与G1垃圾回收器的区别 12 
8.  如何判断垃圾对象？ 8 
9.  堆和栈的区别 8 
10.  可达性分析 7 
11.  GC Root有哪几种？ 7 
12.  CMS 垃圾回收的流程 7 
13.  介绍G1垃圾回收器 4 
14.  新生代和老年代的区别 4 
15.  什么时候发生GC 4 
16.  简述栈溢出情况 4 
17.  简述栈帧存储的内容 3 
18.  对象的生命周期（New出来 到GC ) 3 ✅
19.  简述什么是内存泄漏 3 
20.  JAVA1.8默认垃圾回收器 2 
21.  栈帧是线程私有的吗 2 
22.  标记清除和标记整理的区别 2 
23.  为什么年轻代用复制[算法]() 2 
24.  jps、jstat、jmap、jstack使用 2 
25.  为什么要把永久代换成元空间? 元空间使用直接内存的好处 2 
26.  垃圾对象是否立即回收？ 2 ✅
27.  CMS垃圾回收器为什么进行两次停顿？ 2 
28.  某些垃圾回收器为什么需要STW(Stop The World)？ 2 
29.  频繁gc会有什么问题 2 
30.  简述虚拟机栈包含哪些内容 2 
31.  GC一定会发生停顿吗? 1 
32.  JVM能够提供多大内存？ 1 
33.  新生代为什么分为Eden，From Survive，To Survive三个区 1 
34.  Full GC 过多如何排查分析? 1 
35.  简述Minor GC 与 Full GC及其区别 1 
36.  Jvm1.7 与 1.8的区别 1 
37.  线程共享的位置都哪些 1 
38.  垃圾回收为什么要分区？ 1 
39.  新生代为什么设计eden与sur[vivo]()r两个区？ 1 
40.  CMS并发标记时，那些线程被允许执行？ 1 
41.  三色标记法 1 
42.  哪些垃圾回收器需要STW(Stop The World)? 1 
43.  实例变量能否作为GC root 1 
44.  内存模型中堆和栈的区别 1 
45.  CMS产生空间碎片后，将进行什么操作？ 1 
46.  对象进入老年代的条件 1 
47.  Jvm哪些内存区域不会产生内存溢出 1 
48.  "如果触发新生代GC时，存活对象总量大于sur[vivo]()r区容量，JVM如何处理？" 1 
49.  新生代为什么默认设置年龄为15？ 1 
50.  如果任务过多，线程池的阻塞队列会撑爆哪部分内存区域？ 1 
51.  JDK9采用哪种垃圾回收[算法]()？ 1 
52.  如何理解CMS垃圾回收器对CPU资源敏感？ 1 
53.  Jvm日志出现OOM问题，不能创建本地线程，分析原因，并给出解决办法 1 
54.  方法信息存储区域 1 
55.  简述一下JMM 1 

 

###  **Java框架：** 

1.  SpringAOP的底层原理 51 ✅
2.  SpringBean的生命周期 31 ✅
3.  Spring中IOC的底层原理 28 ✅
4.  SpringMVC工作流程 25 ✅
5.  SpringBoot的常用注解 24 ✅
6.  Spring如何解决循环依赖 22 ✅
8.  Spring、SpringMVC 、Springboot的区别 14 ✅
9.  spring的动态代理模式 14 
10.  SpringBoot 自动装配机制 13 ✅
11.  JWT实现单点登录及流程描述 10 
12.  spring ioc的设计思想和好处 8 
13.  SpringBoot启动过程 8 
14.  mybatis的一级二级缓存有什么区别 7 
15.  @Transactional注解是怎么实现的 7 
16.  简述为什么要使用Spring？(Spring 优势) 6 
17.  SpringMVC处理一个HTTP请求 6 
18.  简述Spring事务 6 
19.  springboot有哪些特性 5 
20.  Spring中事务失效场景有哪些 5 
21.  Mybatis中#与$区别 5 
22.  controller和restcontroller的区别 5 
23.  spring的注入方式有哪些 5 
24.  如何实现Spring事务？ 4 
25.  spring的事务类型 4 
26.  Spring中事务的传播机制 4 
27.  Mybatis分页 4 
28.  springboot的拦截器过滤器 4 
29.  spring bean线程安全问题 3 
30.  Spring Bean的作用域 3 
31.  JUC下的工具包有哪些 3 
32.  springcloud gateway的作用 3 
33.  bean如何创建 3 
34.  JDBC的流程（步骤） 2 
35.  JWT Token存放的内容 2 
36.  springboot怎么实现不同场景下不同配置 2 
37.  Spring特性 2 
38.  springBeanFactury和ApplicationContext的区别 2 
39.  featoryBean和beanFeatory的区别 2 
40.  Spring事务的实现 2 
41.  JWT使用场景 2 
42.  DispatcherServlet是每次拦截到url都会新建一个吗 1 
43.  springboot的autowaire注解原理 1 
44.  什么是SpringBoot 1 
45.  spring的三级缓存  1 
46.  简述mybatis框架 1 
47.  Mybatis mapper工作原理 1 
48.  Spring包含哪些模块 1 
49.  spring actuator的实现原理 1 
50.  微服务对比单体架构的有什么优势 1 
51.  微服务多实例配置修改的解决方案 1 
52.  k8s提供了哪些好的特性支持微服务 1 
53.  springboot和传统java开发的优势 1 
54.  Mybatis的优点 1 
55.  mybatis传参的四种方式 1 
56.  如何保证ElasticSearch的高可用 1 
57.  SpringBoot如何自定义starter 1 
58.  如何实现微服务的健康状态检测 1 
59.  @Resource和@Autowired有什么区别？ 1 
60.  数据库连接池的优点 1 
61.  Spring Boot和Spring Cloud的区别 1 
62.  Mybatis如何完成SQL和接口里的方法映射？ 1 
63.  spring中的xml文件何时被初始化 1 
64.  Spring加载配置文件的顺序 1 

###  **设计模式** **：**  

1.  常见的设计模式与优缺点 32 
2.  单例模式的几种实现方式 26 ✅
3.  Spring使用了哪些设计模式？ 9 ✅
4.  面向对象的三大特征 8 
5.  简述什么是装饰器模式 6 
7.  简述面向对象的理解 4 
8.  秒杀如何防止超卖？ 4 
9.  手撕观察者模式 2 
10.  怎么理解单一职责原则 2 
11.  工厂模式有哪几种？ 2 
12.  简述什么是开闭原则 2 
13.  Spring工厂模式和单例模式的作用 2 
14.  设计模式六大准则 1 
15.  设计一个任务调度系统，每个任务触发频率不同，保证每个任务顺利运行 1 
16.  设计一个带有群聊功能的聊天软件（需求到每个功能点） 1 
17.  原型模式深拷贝实现原理 1 
18.  举例说明使用单例模式的场景 1 
19.  简述什么是策略模式 1 
20.  设计朋友圈的类(包含 关注与被关注关系 关注的人发动态） 1 
21.  简述什么是模板模式 1 
22.  设计一个抢红包程序(从 表、流程、逻辑 三个方面来阐述) 1 
23.  springboot的设计模式 1 
24.  设计游戏排行，展示前100名和当前用户的名次？ 1 
25.  为什么要使用设计模式 1 
26.  如何设计一个缓存数据结构?(考虑线程安全，以及查找、修改、删除的性能） 1 
27.  手写一个设计模式（非单例、工厂） 1 
28.  如果用户很久没有登陆，消息量过多怎么办？ 1 
29.  代理模式的优缺点 1 
30.  如何设计万人群聊 1 
31.  IO中用到的设计模式？ 1 
32.  面向对象与面向过程的编程思想的区别 1 

###  **JavaIO:** 

1.  IO多路复用原理 12 
2.  select、poll和epoll区别和特点 9 
3.  select和epoll的区别 5 
4.  BIO、NIO、AIO的区别 4 
5.  epoll原理 2 
6.  服务器给客户端发送IO流的过程 1 
7.  epoll的两种触发与使用场景 1 
8.  NIO与BIO的区别 1 
9.  简述[Netty]()的特性 1 
10.  [Netty]()的线程模型 1 

###  **Java服务器:** 

1.  Tomcat底层原理 1 
2.  集群服务器之间如何同步数据 1 
3.  Tomcat生产环境如何部署 1 

#  **Network** 



###  传输层 

1.  Tcp与Udp区别 93  ✅
2.  Tcp三次握手四次挥手及对应的状态 73 ✅
3.  Tcp流量控制与拥塞控制 57  ✅
4.  Tcp如何保证可靠传输 45 ✅
5.  TCP为什么要三次握手 33 ✅
6.  四次挥手timewait的作用 30 ✅
8.  TCP为什么粘包？如何处理 15 ✅
9.  TCP为什么要四次挥手 13 
11.  TCP滑动窗口的作用 10 
12.  如何设计可靠的UDP 9 
13.  closewait的作用 6 
14.  SYN洪泛攻击与应对方案 5 
15.  Tcp与Udp相关协议 5 
16.  列举拥塞控制的几种[算法]() 4 
16.  TCP半链接队列和全连接队列 4 ✅
17.  Udp使用场景 4 
18.  TCP为什么要进行拆包？ 4 
19.  TCP建立连接后传输数据的具体过程 3 
20.  服务端time-wait太多，如何解决？ 2 
21.  如果第一次握手后，服务端宕机会怎样？ 2 
22.  Tcp的选择重传机制 2 
23.  TCP超时重传时间与次数 2 ✅
24.  如何验证传输报文是否完整？ 2 
25.  UDP为什么快？ 2 
26.  "第三次挥手，如果客户端挂了， 服务端拿不到客户端响应，如何应对？" 2 
28.  数据接收方还会有滑动窗口吗 1 
29.  如何搭建TCP高并发服务器 1 
30.  UDP能携带的数据最大长度是多少？ 1 
31.  Linux 内核如何实现 TCP ？ 1 
32.  UDP还会做数据校验吗 1 
33.  last ack状态作用 1 
34.  四次挥手出现TimeWait的条件 1 
35.  TCP是长连接还是短链接 1 
36.  UDP报文格式 1 
37.  都有什么地方用到了TCP 1 
38.  TCP 有哪几种关闭的情况？ 1 
39.  发送方怎么判断丢包？ 1 
40.  使用udp还想保证数据不丢失如何处理 1 
41.  TCP 里的 RTT 和 RTO 怎么测量的？ 1 
43.  滑动窗口的大小是如何确定的？ 1 
44.  四次挥手为什么要等待2MSL？ 1 
45.  列举传输层的协议 1 
46.  UDP包大于1472字节能够发送成功吗？ 1 

###  Http相关 

1.  Http、Https、两者区别 72 ✅
2.  Https的加密流程 35 ✅
3.  Get与Post的区别 32 ✅
4.  Http响应状态码 21 ✅
5.  Http请求、响应的报文格式 19 ✅
6.  Http2.0、Http1.1、Http1.0有哪些特性 10 ✅
7.  http协议的几种方法（get、post、delete等） 6 ✅
9.  https如何保证可靠性 5 ✅
10.  Http 头的内容 4 
11.  http请求中的跨域问题 4 
12.  Http如何保证安全传输 4 
13.  Http重定向的返回状态码 3 
14.  Http中的content-type有哪些 3 
15.  SSL如何加密 3 ✅（同2）
16.  Http可以长连接，但为何还是无状态？ 2 
17.  对称加密与非对称加密的关系 2 
18.  Https的TLS的工作原理 2 
19.  Http与Https的端口号 2 
20.  Http与Tcp的关系与区别 2 ✅
21.  长连接与短连接 1 
22.  非对称密钥[算法]() 1 
23.  HTTP无状态，如何标注用户身份 1 
24.  http断电续传能力怎么实现的 1 
25.  "请求页面的资源分布在不同服务器， 需要建立几次Http和TCP连接？" 1 
27.  Http与Rpc的关系 1 
28.  POST 有哪几种编码方式 1 
29.  Http的缺点 1 
30.  https建立连接的过程 1
31.  Https建立连接时服务器返回的证书的内容 1 
32.  Http2.0 二进制分帧改进 1 
33.  简述CA证书 1 ✅
34.  Https加密[算法]()用在哪个步骤？ 1 
35.  如何断点续传？ 1 
36.  Https为什么安全？ 1 
37.  Http1.1线头阻塞问题 1 
38.  [keep]()-alive在http和tcp/ip中的区别 1 
39.  http2.0引入多路复用的目的 1
40.  Http是基于Tcp还是Udp? 1
41.  Web服务器是如何解析HTTP请求报文 1

###  网络体系结构 

1.  浏览器上输入地址后的整个请求过程 71 ✅
2.  OSI七层、五层模型，每一层的作用 61 
3.  Tcp/ip的四层协议，协议 17 
4.  MySQL建立连接的过程 1 
5.  网络模型为什么要分层 1 
6.  如果你使用无线局域网，访问网址很慢如何排查？ 1 
7.  网络数据转发的全流程（交换机/路由器报文传输具体流程） 1 
8.  客户端与服务端建立连接后是否会保持？何时释放？ 1 
9.  BS与CS的区别 1 
10.  服务端如何记录客户端登陆状态？ 1 

###  应用层 

1.  Cookie与Session原理与区别 30 ✅
2.  DNS工作原理 21 ✅
3.  列举应用层协议 3 
4.  浏览器禁用了Cookie以后还能用Session吗 2 ✅
5.  列举不同的编码方式，并分析其区别 1 
6.  dns除了能查ip还能查到什么 1 
7.  网关同时接到10个请求，是并行处理还是串行处理？ 1 
8.  URL中的中文字符为什么需要转码 1 
9.  如果晚上0点有大量请求，如何区分恶意与善意请求？ 1 
10.  分布式session，如何实现？ 1 
11.  域名相同，协议不同，cookie是否可以传递？ 1 
12.  简述DDoS的攻击方式与原理 1 
13.  简述黑客攻击某个主机的方法与过程 1 

###  网络层 

1.  简述ARP协议流程 5 
2.  ICMP，ARP，IGMP原理 4 
3.  子网掩码的作用 2 ✅
4.  列举并简述路由协议 2 
5.  路由器工作原理 2 
6.  ping的过程 2 
7.  ARP和RARP的区别 2 
8.  IP协议是否可靠并说明原因 1 
9.  什么是网段？ 1 
10.  Mac地址与IP地址的关系 1 
11.  A能ping通B，B不能ping用A，如何排查问题 1 
12.  网络层报文和报头 1 
13.  电脑多网卡，IP数据包如何选择网卡发送 1 
14.  列举网络拓扑结构 1 
15.  IPv4地址与IPv6地址的区别 1 
16.  如何实现软路由 1 
17.  分析说明IP层协议 1 
18.  私网如何访问到[百度]()？ 1 
19.  公网和私网如何区分？ 1 
20.  NAT实现原理 1 
21.  ip地址和mac地址的区别 1 
22.  二层交换机和三层交换机的区别 1 

###  Socket相关 

1.  NIO的实现模型 6 
2.  Socket实现三次握手 5 
3.  Socket与WebSocket的区别与联系 3 
4.  Socket的系统调用 2 
5.  Socket与Channel的区别 2 

###  链路层 

1.  交换机工作原理 3 
2.  数据链路层有哪些协议 2 
3.  数据链路层的报头和报文 1 

#  **Mysql** 

###  Mysql索引 

1.  索引的数据结构对比（hash、B树与B+树），为什么不用[红黑树]() 100 ✅
2.  Mysql索引数据结构 61 ✅
3.  Mysql的聚簇索引和非聚簇索引作用与区别 45 ✅
4.  索引失效的几种场景 40 ✅
5.  Mysql索引优化与设计规则 33 ✅
6.  索引的最左匹配原则 23 
7.  简述索引作用与优缺点 19 ✅
8.  简述索引覆盖与回表查询 16 
9.  简述索引分类 8 
10.  简述什么是联合索引 7 ✅
11.  唯一索引与主键索引的区别 6 ✅
12.  什么时候需要加索引 4 
13.  主键为什么自增，不自增是否可行 4 
14.  简述什么是索引下推 3 ✅
15.  联合索引与多个单列索引的区别 2 
16.  如何对Sqls语句进行索引使用分析 2 
17.  简述什么是索引倒排 1 
18.  如何创建表索引 1 
19.  简述什么是全文索引 1 
20.  简述页合并与页分裂 1 
21.  新建索引需要注意什么 1 
22.  非主键索引底层实现有什么特点？ 1 
23.  如何判断一张表有没有使用索引？ 1 
24.  读写分离的数据库，是否有必要建立聚簇与非聚簇索引？ 1 
25.  索引树的高度及计算方法

###  Mysql事务 

1.  Mysql的默认隔离级别、不同等级隔离级别解决的问题与实现原理 103 ✅
2.  Mysql事务及特性 67 ✅
3.  Mvcc实现机制(RC和RR隔离级别下的区别) 45 ✅
4.  Mysql的bin log redo log undo log日志文件及其作用 25 ✅
5.  什么是两阶段提交 24 ✅
6.  如果两阶段提交异常mysql重启会发生什么 23 ✅
7.  解释脏读、幻读及产生条件 22 
8.  MVCC 是否能彻底解决幻读 4 ✅
9.  事务四个特性中隔离性的作用 4 
10.  不可重复读与幻读的区别 3 ✅
11.  如何实现可串行化隔离级别，来避免幻读？ 2 
12.  Mvcc如何提高并发度 2 
13.  事务失效的场景举例 1 
14.  ACID怎么保证原子性 1 ✅（同17）
15.  脏读、幻读、可重复读的概念以及解决方法 1 
16.  ACID怎么保证隔离性 1 
17.  mysql事务回滚及提交的原理 1 ✅
18.  能不能只要bin log或者redo log? 1 ✅
19.  数据最终落盘是从redo_log更新来的，还是从内存更新来的？1 ✅

###  查询性能优化 

1.  Mysql sql优化，慢Sql如何排查 40 ✅
2.  Inner join与left join区别 16 ✅
3.  Mysql查询优化器机制 5 
3.  大表怎么优化 5 ✅
4.  sql语句执行流程？5
5.  如何避免回表查询 5 
6.  结合Explain分析Sql语句的索引使用情况 4 
7.  explain会出现几种索引扫描类型？出现filesort的场景 4 
8.  union和union all区别 3 
9.  count(1)、count(*)、count(列名)区别 2 
10.  多表查询时，join和子查询哪个效率高 2 
11.  如果数据量变大，分页变慢，limit如何优化？ 1 
12.  整型字段加索引进行范围查找的优化 1 
13.  查询条件> 5 和 >= 6 哪一个比较好？ 1 
14.  explain 有哪些字段 1 
15.  leftjoin与rightjoin区别 1

###  存储引擎与锁

1.  Mysql的几种存储引擎 34 
2.  Innodb与myisam的区别、应用场景 21 
3.  简要说明Innodb的优势 3 
4.  Mysql锁机制 
5.  Mysql有哪几种锁 16 
6.  乐观锁与悲观锁的区别 9 
7.  行锁与表锁的区别 7 
8.  Mysql产生死锁的原因及解决方案 4 
9.  间隙锁的作用与应用场景 3 
10.  按照索引查询是否会发生死锁 2 
11.  什么时候会出现表锁 1 
12.  MySQ如何手动去检测死锁 1 
13.  设计Mysql锁的数据结构 1 
14.  间隙锁，记录锁与临间锁的区别 1

###  Mysql基础 

1.  数据库三范式 18 
2.  关系型数据库与非关系型数据库区别 3 
3.  Drop delecte truncate  3 
4.  sql 语句的执行顺序 3 
5.  Mysql数据存储形式 2 
6.  char与varchar的区别 2 
7.  update或者insert语句内部执行过程？ 2 
8.  Order by 和 Group by的区别 1 
9.  having和where的区别 1 ✅
10.  Mysql基本数据类型 1 
11.  如何删除数据库表中重复的数据 1 
12.  为什么主键用自增不用UUID 1 
13.  数据库视图与表的区别 1 
14.  左连接、右连接、内连接、外连接的区别 1 
15.  如何进行数据库设计 1 
16.  Mysql如何进行查询结果合并？ 1 
17.  isEmpty()和isBlank()的区别 1 

###  分库分表 

1.  分库分表 18  ✅

###  Mysql问题与解决方案 

1.  如何防止sql注入 5 
2.  数据高写入量场景，如何设计数据读取方案？ 1 
3.  如何防止库存减为0？ 1 
4.  Mysql如何实现分页查询？ 1 
5.  Mysql承受不住压力怎么办？ 1 
6.  Mysql如何实现高可用？ 1 
7.  如何解决分布式存储的数据一致性问题 1 
8.  Mysql如何实现高性能？ 1 
9.  字段存在唯一性约束，数据库设计需要考虑哪些？ 1 
10.  Mysql如何实现数据备份 1 
11.  如何从一亿数据中分页获取某用户所有数据 1 
12.  Mysql单表数据量过大会有啥问题？为什么数据量不能过大 1

###  Mysql复制 

1.  Mysql主从复制过程 10 
2.  如何应对主从同步延迟 1 
3.  主从一致性如何保证 1 
4.  简述Mysql半同步机制 1 

#  **OS** 

###  进程管理 

1.  进程与线程的区别 69 
2.  进程之间通信方式 38 
3.  进程、线程、协程的区别 24 
4.  常见的进程调度[算法]() 16 
5.  线程间通信方式 13 
6.  线程的状态 9 
7.  进程的状态 7 
8.  简述什么是僵尸进程 6 
9.  如何实现进程间共享内存？ 4 
10.  僵尸进程和孤儿进程的区别 4 
11.  如何启动和杀死进程 3 
12.  管道的底层实现原理 3 
13.  线程上下文切换如何实现 3 
14.  简述信号量机制 2 
15.  简述fork函数的作用 2 
16.  如何解决僵尸进程 2 
17.  有名管道与无名管道的区别 2 
18.  文件描述符如果发生更新，如何通知对应进程或者线程 1 
19.  单个进程最多能创建多少个线程 1 
20.  操作系统调用线程的方法 1 
21.  Linux中如何创建进程 1 
22.  说明信号量与信号的区别 1 
23.  Linux内核如何进行线程维护 1 
24.  多个进程监听一个端口，如何防止惊群？ 1 
25.  简述什么是孤儿进程 1 
26.  创建进程的系统调用 1 
27.  列举Linux系统中的锁类型 1 
28.  实现一个聊天室需要几个进程几个线程？ 1 
29.  列举常用软件的端口号 1 
30.  为什么进程上下文切换开销大 1 
31.  如何保证端口安全 1 
32.  线程、进程切换的差别 1 
33.  如何保证信号量对两个进程可见？ 1 
34.  进程安全如何实现 1 
35.  如何解决端口占用 1 
36.  常见的线程阻塞方法 1 
37.  Linux内核如果实现进程管理 1 
38.  进程占用资源过多, 如何解决 1 

###  Linux命令 

1.  熟悉的Linux命令举例 44 
2.  如何查看端口占用 12 
3.  查看进程内存与CPU占用情况 7 
4.  进程终止命令（kill 与 kill - 9 的区别） 6 
5.  常用命令有哪些 5 
6.  进程状态查看的命令 3 
7.  top命令的作用 2 
8.  如何从日志信息中找到一些敏感词 2 
9.  如何查看某个进程打开了哪些文件? 2 
10.  查看所有运行进程命令 2 
11.  如何杀死正在运行的Redis服务 2 
12.  文件夹下.txt后缀文件的查找命令 2 
13.  文件权限的设置 2 
14.  修改文件权限的命令 2 
15.  如何查看Linux磁盘信息 2 
16.  find和grep的区别 2 
17.  linux用什么命令查看文件 1 
18.  chmod权限用法 1 
19.  如何查看日志文件中topK的错误日志 1 
20.  awk命令及作用 1 
21.  如何通过iostat判断io过高？ 1 
22.  简要说明netstat命令功能与作用 1 
23.  查看文件是被占用 1 
24.  Linux查看隐藏文件 1 
25.  Vim操作的基本和快捷指令？ 1 
26.  ping的原理 1 
27.  如何使用Linux命令进行文件查找 1 
28.  ping使用的是长连接还是短链接 1 
29.  linux 怎么查大于50MB文件 1 
30.  如何查看当前系统开放的全部端口 1 
31.  查看网络相关的命令 1 
32.  find命令使用方法 1 
33.  用什么命令修改ip地址 1 
34.  linux查找文件倒数100行的内容 1 
35.  过滤目录下包含某个字符串所在文件的命令 1 

###  内存管理 

1.  虚拟内存及其作用介绍 29 
2.  内存泄露概念与产生原因与影响 12 
3.  简述页面置换[算法]() 7 
4.  内存溢出的产生原因与相关处理 6 
5.  操作系统分页，分段，TLB 6 
6.  操作系统如何管理内存资源？ 4 
7.  逻辑地址怎么变成物理地址 4 
8.  进程的内存分配（低地址到高地址） 4 
9.  什么是缺页中断？ 2 
10.  内存分配[算法]() 2 
11.  简述什么是线程泄露 1 
12.  处理缺页中断的淘汰[算法]() 1 
13.  磁盘读取文件到网络发送，要经过多少次内存 1 
14.  虚拟内存如何优化进程间的上下文切换 1 
15.  负载与CPU使用率的关系 1 
16.  父进程fork子进程，子进程申请大量内存后崩溃，是否会造成内存泄露 1 
17.  简述磁盘调度[算法]() 1 

###  死锁 

1.  死锁的产生条件与解决方案 36 
2.  如何查看当前线程，并判断死锁 1 

###  OS基础 

1.  用户态内核态区别 6 
2.  并发与并行的区别 6 
3.  中断的分类与区别 3 
4.  用户态如何切换到内核态 2 
5.  系统调用的全过程 2 
6.  os的组成 1 
7.  异步和并行的区别 1 

###  链接 

1.  介绍软链接与硬链接 2 
2.  介绍静态与动态链接 2 

###  设备管理 

1.  select与poll的区别 1 
2.  epoll底层实现 1 

​    


#  Redis 

###  Redis问题与解决方案 

1.  缓存穿透、缓存雪崩原因及解决方案 36  ✅
2.  Redis缓存与如何保证数据一致性问题 32 
3.  简述Redis中布隆过滤器的应用 11 
5.  Redis与Mysql如何同步？ 3 
6.  如何实现分布式缓存？ 3 
7.  分布式限流[算法]()、单机限流[算法]() 3 
8.  Redis宕机，会不会有数据丢失的情况，如何解决？ 3 
9.  一致性hash，如何增加、删除节点 3 
10.  Redis的线程模型 2 
11.  Redis高可用方案 2 
12.  Redis如何进行容灾 1 
13.  如何应对Redis Zset打满的情况 1 
14.  Redis如何实现排行榜？ 1 
15.  "Redis如何应付上万条用户的同时注册, 并确保多服务器的注册能够用户账号唯一" 1 
16.  Redis如何解决超发问题 1 
17.  [redis]()和mysql的区别 1 
18.  Redis发布订阅和消息中间件的区别 1 
19.  [redis]()可以在磁盘中使用吗 1 
20.  如何实现缓存预热？ 1 
21.  [redis]()中hash扩容怎么实现 1 
22.  Redis单机故障如何处理 1 
23.  RRedis发布订阅和直接用List的区别 1 
24.  Redis数据量特别大，是否会阻塞？ 1 

###  Redis数据类型 

1.  Redis基本数据类型 76 
2.  String类型的底层数据结构 3 
3.  bitmap 数据类型 2 
4.  Redis的String与Java的String的区别 1 

###  Redis数据结构 

1.  Redis底层数据结构与数据类型 35 
2.  Zset的底层实现 20 
3.  跳表的实现原理 12 
4.  跳表的时间复杂度分析 1
5.  压缩列表的实现原理 1 

###  Redis使用场景 

1.  Redis如何实现分布式锁？ 36  ✅
2.  分布式锁的超时设计与优化 10 
3.  简述Redis使用场景 7 
4.  Redis集群如何设计 4 
5.  实现消息队列 2 ✅
5.  Redis实现限流的方式 2 ✅
6.  简述Redis服务降级 2 
7.  Redis如何管理token的生命周期 1 
8.  Redis如何实现文章热榜 1 
9.  简述Redis如何解决数据倾斜 1 
10.  Redis如何实现消息已读未读 1 

###  Redis持久化 

-  Redis持久化方式，RDB和AOF的区别与优劣势 45 

###  Redis特性 

1.  Redis单线程为何速度快？ 27 
2.  为什么用Redis？ 6 
3.  Redis与Mysql的区别 5 
4.  Redis有哪些特性？ 2 
5.  Redis为什么使用单线程？ 2 
6.  Redis的IO多路复用与系统调用 1 

###  过期与淘汰策略 

1.  Redis缓存淘汰策略 16 
2.  Redis过期策略 13 
3.  Redis的近似LRU详细解释 1

###  Redis复制 

-  Redis的主从同步设计 8 

###  Redis事务 

-  Redis是否支持事务 4 

###  Sentinel哨兵 

-  Redis的哨兵模式 3 

###  Redis其他

-  Redis 与 Memcached区别 1 
-  Redis4.0和6.0的变化趋势 1

#  DataStructure 

###  树 

1.  简述什么是B+树 22 
2.  B+树与B树的区别 21 
3.  简述什么是[红黑树]() 17 
4.  [红黑树]()与二叉平衡树的区别 8 
5.  堆的时间复杂度分析 6 
6.  二叉平衡树的介绍 6 
7.  [二叉树]()的数据结构 6 
8.  [二叉树]()有哪些？ 4 
9.  b+树与[二叉树]()的区别 2 
10.  简述什么是B树 2 
11.  列举所有树并横向对比 2 
12.  简述为何二叉平衡树左右子树高度差不超过1 2 
13.  简述二叉搜索树的数据结构 2 
14.  简述[二叉树]()与堆的关系 2 
15.  跳表与[红黑树]()的比较 1 
16.  哈夫曼树的使用场景 1 
17.  二叉搜索树的时间复杂度？ 1 
18.  简述堆的特性(大根堆、小根堆) 1 

###  [排序]() 

1.  常用[排序]()[算法]()举例 27 
2.  快排时间复杂度分析（快排） 7 
3.  手写堆[排序]() 3 
4.  列出所有稳定[排序]()和不稳定[排序]() 3 
5.  分析说明快速[排序]()[算法]()（快排） 3 
6.  手撕快速[排序]()（快排） 2 
7.  常用[排序]()[算法]()复杂度分析 2 
8.  如何在两个大数据文本(50亿)中，找相同的单词（内存4M） 1 
9.  洗牌[算法]() 1 
10.  手撕归并[排序]() 1 
11.  分析说明选择[排序]()[算法]() 1 
12.  1个亿的数据 如何找前一万个大的数？ 1 
13.  冒泡[排序]()时间复杂度分析 1 
14.  100G的文件，如何[排序]()? 1 
15.  快排最坏时间复杂度及分析 1 

###  线性表 

1.  数组与[链表]()的区别 29 
2.  数组遍历方法的时间复杂度分析，如何优化？ 2 
3.  [链表]()遍历的时间复杂度分析，如何优化？ 1 
4.  [链表]()的头插和尾插 1 
5.  数组随机访问如何寻址 1 

###  查找 

1.  Hash冲突解决方案 11 
2.  简述一致性Hash[算法]() 2 
3.  简述hash的实现 1 

###  DS基础 

1.  递归和循环的优劣性对比 2 
2.  不使用For while，如何实现循环？ 2 
3.  递归的弊端与应对方案 1 
4.  常用的数据结构有哪些 1 

###  栈与队列 

1.  栈与队列的区别 5 

###  图 

1.  图遍历的方式 2 
2.  深度优先搜索和广度优先搜索的区别 1 
3.  最小生成树[算法]() 1 
4.  最短路径[算法]() 1 

#  Test 

###  软件测试基础 

1.  软件测试方法 11 
2.  测试开发需要哪些技能？ 6 
3.  简述黑盒测试方法 3 
4.  简述白盒测试方法 3 
5.  性能测试关注点 2 
6.  CPU占用异常，如何定位？ 2 
7.  如何测试[百度]()搜索框？ 2 
8.  v,w模型 1 
9.  软件测试计划的主要内容 1 
10.  软件测试的主要流程 1 
11.  测试用例设计方法 1 
12.  分析淘宝网页的测试功能点 1 
13.  简述自动化用例的设计思路 1 
14.  软件测试的具体流程 1 
15.  测试与测试开发的区别 1 
16.  打开网页导致黑屏有哪些原因？ 1 
17.  如何设计测试用例？ 1 
18.  软件生命周期 1 
19.  如何设计转账的测试用例 1 
20.  性能测试如何保证与实际场景类似？ 1 
21.  如何使用测试用例 1 
22.  如何诊断流量异常 1 

#  MQ 



###  MQ可靠性 

1.  怎么保证Kafka消费不乱序 5 
2.  Rabbitmq如何保证可靠性 2 
3.  如何保证Kafka的数据一致性 2 
4.  ActiveMQ如何解决消息重复问题 2 
5.  消息重复消费，消费失败如何处理 2 
6.  下单事务失败了，如何回滚？ 1 
7.  消费消息时幂等性如何保证 1 
8.  Rabbitmq如何保证消费的顺序性 1 
9.  如何保证Kafka的高可用 1 
10.  rabbitmq如何实现广播 1 
11.  ActiveMQ如何解决消息丢失问题 1 
12.  rocketMq如何保证消息被发送和接收 1 

###  MQ消息模型 

1.  Kafka架构 7 
2.  MQ架构 2 
3.  Kafka的优缺点 2 
4.  Kafka的message压缩机制 1 
5.  Kafka与其他MQ的对比 1 
6.  RabbitMq和kafka的区别 1 
7.  ActiveMQ原理 1 
8.  KafKa为什么快？ 1 

###  MQ使用场景 

1.  如何实现流量削峰？ 4 
2.  如何解决生产者消费者生产和消费速率不同的问题 1 
3.  如何实现MQ死信取消超时单？ 1

# 微服务

## 限流

1. 如果要对大流量接口进行限流，在哪一层做，思路是什么

