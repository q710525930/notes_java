# 系统设计题

## 一. 设计秒杀系统



## 二. 设计微信红包系统



## 三. 设计短连接系统

为什么要短连接？

因为用户在分享链接比如分享淘宝、抖音等链接到微信或者发短信给用户的时候有长度限制，所以需要将链接缩短，或者一些app无法自动识别长连接跳转。



短连接原理：

- 页面跳转
  - 使用302（临时跳转），而不使用301（永久重定向），因为301用户再次访问直接从浏览器缓存拿到url就请求了，不利于服务端统计调用次数和其他数据统计
  
- 长短链接映射
  - hash算法：
    - 短链由固定域名加上后缀组成，可以用hash算法将长连接映射为短字符后缀，由于hash算法会带来性能损耗，但是此场景下不用考虑hash反向解密，只用考虑hash计算速度和冲突率，可以选择一些性能损耗比较小的算法如Google的MurmurHash算法
    - 对上面映射后的hash，从10进制转为62进制（0~1a~zA~Z）可以进一步缩短长度
  - 数据库自增id算法：
    - 维护一个自增id计算器，收到一个长链转短链的请求时，ID 生成器为其分配一个 ID，再将其转化为 62 进制，拼接到短链域名后面就得到了最终的短网址
    - 获取自增id的方法：
      - **UUID**：UUID uuid = UUID.randomUUID()，它保证对在同一时空中的所有机器都是唯一的，但这种方式生成的 id 比较长，且无序，在插入 db 时可能会频繁导致**页分裂**，影响插入性能。
      - **Redis**：性能好，单机可支撑 10 w+ 请求，足以应付大部分的业务场景，如果一台机器扛不住呢，可以设置多台，比如我布置 10 台机器，每台机器分别只生成尾号0，1，2，... 9 的 ID, 每次加 10即可，只要设置一个 ID 生成器代理随机分配给发号器生成  ID 就行了。**需要考虑持久化（短链 ID 总不能一样吧），灾备，成本有点高**
      - **Snowflake**：雪花算法，依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成 ID 冲突，或者 ID 乱序。
      - mysql**自增主键**：随时生成对db压力较大，可以预先分配，比如设计一个专门的发号表，每插入一条记录，为短链 id 预留 （主键 id * 1000 - 999） 到 (主键 id * 1000) 的号段，如下![img](/Users/xx/Downloads/notes_java/面试题/pic/170dd2ed3f69c2c1~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)tmp_start_num 代表短链的起始 id，tmp_end_num 代表短链的终止 id。当请求到一台机器时，先检查机器的号是否分配完，分配完了就去数据库插入数据，插入成功后返回。**单机内部实现可以用LongAdder代替AtomicLong**
  
- 数据库
  
  - 创建一个长短链的映射表即可， 短链 id 即为主键。为了防止同一个链接多次生成短链的不同，需要每次先根据长链来查找 db 看是否存在相关记录，一般的做法是根据长链做索引，但这样的话索引的空间会很大，所以我们可以对长链的 MD5 字段做索引，这样索引就会小很多。这样只要根据长链的 md5 去表里查是否存在相同的记录即可。
  
  - ```sql
    CREATE TABLE `short_url_map` (
      `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '短链 id',
      `lurl` varchar(10) DEFAULT NULL COMMENT '长链',
      `md5` char(32) DEFAULT NULL COMMENT '长链md5',
      `gmt_create` int(11) DEFAULT NULL COMMENT '创建时间',
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    ```
  
    数据量很大的情况下后面需要分库分表

- 短连接请求
  - 正常是请求过来的短连接，去数据库查询对应长连接，然后返回。为了防止数据库压力过大，中间添加一个布隆过滤器，如果不存在的短连接则直接拒绝掉

方案B：

> **1：主体设计**
>
> 短链尾缀只允许3位 - 4位。可用字符为0-9a-z   （为什么不用大写字母是因为前端大佬提出有些浏览器不区分大小写或可以设置不区分大小写。），短链尽可能多，且使用时随机出。
>
> 对此我的方案是:两种选择，第一个是使用MySQL：按域名**分表**，每个域名一个尾缀表，事先将3位和4位的尾缀随机生成导入尾缀库。短链表和尾缀表关联，3位先使用，4位后使用。这样一个表大约173w行短链。之后扩容直接扩域名扩表即可，保证可扩展。使用尾缀按id自增顺序依次使用即可，使用redis记录每个域名使用的当前最大id，来做分布式锁控制。保证不重复生成。
>
> 第二种是如果你要生成更多如5、6位，使用HBase加[二级索引](https://www.zhihu.com/search?q=二级索引&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2340402141})，替换MySQL方案。这个方案很复杂不说了。再说要收费了。
>
> 说到HBase,这本书还是非常推荐的,搞JAVA的同学们可以看看。
>
> 上述其实就是这个方案的所有精髓了。
>
> 为什么要3或4位？因为短信70个字符是一个计费，超出算两条。为了其他话术多写字，要近可能压缩短链空间。
>
> 
>
> 注意上述生成的时候需要排除一些屏蔽词：如f u c k 等。
>
> **2：短链回收机制**
>
> 按照一定业务的规则把使用过的短链尾缀回收掉。保证循环使用，且不影响功能。我这里是 每晚的定时任务触发规则处理。由于尾缀表是固定好的，回收只需要把需要回收的尾缀放到尾缀表的最后即可。可把我聪明坏了。
>
> **3：短链套短链，套娃操作**
>
> 业务统计需要用一个短链跳转另一个，跳好几层（为了分不同维度统计短链点击情况）。
>
> 这点绝对不能用前端直接跳转，要在后端找链路去跳转，最后返回原链接即可。具体逻辑就是个类似递归操作了，需要处理很多异常情况。可以考虑一些好的设计模式（目前我这边直接怼的）。
>
> **4：限流**
>
> 根据ip等信息做接口限流，防止刷。这个不具体介绍了。懂得都懂。
>
> **总结：精髓就是，按短链域名分表，提前生成尾缀依次使用，尾缀过期回收。**

参考文档：https://juejin.cn/post/6844904090602848270



## 四. 设计一个限流器

### 单机

限流算法：

- **固定窗口**：固定时间窗口比如1-2s内，可以容纳100个请求，缺点是如果在1.9s时来了99个接口，2.1s时来了99个请求时不会报错的，这样实际上1.5s~2.5s之间就有99+99个请求，也就是**理论上最大流量能达到设计的两倍**
- 滑动窗口：滑动窗口根据请求的时间往前找一个时间窗口，查看这个时间窗口的请求量是否超过了阈值，如果没有超过则处理请求，否则拒绝处理该请求。但是**对内存的消耗会比较高**
- **漏桶法**：想象一个桶容纳请求，来了请求就往桶里面灌，定期从桶里面取出请求处理，桶满了表明达到最大容量拒绝请求，实现上可以用FIFO请求队列实现。缺点是前面请求的处理慢了会阻塞后面的请求。
- 令牌桶算法：和漏桶法相反，漏桶法是机器定期取请求，新来的请求往里面放；令牌桶是新来的请求定期取桶里面的令牌，取到就表明可以处理，机器定期往桶里放令牌，能够解决令牌桶的请求处理速度不均匀的问题。

### 分布式

方法：

- 在负载均衡层面做，好处是全局统一
  - 缺点：负载均衡器一般是云服务商提供的，一般的程序员可能无法直接在上面写代码。并且配置在负载均衡器上也做不了容错，可能还会影响扩容。
- Redis：使用一个中心化存储器，让分布式也像单机一样。每个节点收到来自上游的请求后直接请求数据库，然后数据库根据限流器判断是否处理这个请求，最后返回给节点相关信息。如果用Redis实现，限流器的代码可以通过Lua脚本的方式放在Redis端，从而减少节点访问Redis的次数。
  - 缺点：流量小可以撑住，流量大的话请求都要到redis会造成redis压力大，返回延时高，
- Redis改进：在节点内积攒到N个请求再去请求redis，可以降低redis的请求量为1/N，但是本地请求积攒期间也会导致延时。可以考虑，在负载均衡非常平均的情况下，每个机器的本地限流器值设置为集群的1/N，这个N的值使用redis或者zookeeper保存，集群机器保证不断更新这个N值即可。



## 五. 设计一个IM即时聊天软件

