## TCP

### TCP特性

**TCP 是面向连接的运输层协议**

- 一个应用进程在向另一个进程发送数据之前，两个进程必须先建立 TCP 连接，发送某些预备报文段，以建立确保数据传输的参数。

**TCP 连接提供全双工服务**

- 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都有各自的发送缓存和接收缓存，用来临时存放双向通信的数据。

**TCP 提供可靠的交付服务**

- 通过 TCP 连接传送的数据无差错、不丢失、不重复，并且按序到达。

**TCP 是面向字节流的**

- 面向字节流的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但是 TCP 把应用程序交下来的数据仅仅看成一连串无结构的字节流。

### TCP可靠性原理

TCP 的可靠传输包含很多机制，例如使用**检验和**来检测一个传输分组中的比特错误、使用**定时器**来用于超时重传一个分组、使用**序号**来检测丢失的分组和冗余副本、使用**确认**来告诉发送方确认的分组信息、使用**否定确认**来告诉发送方某个分组未被正确接收。

TCP 的发送方仅需维持已发送过但未被确认的字节的最小序号和下一个要发送的字节的序号，从这种角度看 TCP 更像一个 GBN 协议。但是 TCP 和 GBN 有一些显著的区别，许多 TCP 实现会将正确接收但失序的报文段缓存起来。当分组 n 丢失时，GBN 会重传 n 之后的所有分组，但是 TCP 至多只会重传分组 n。对 TCP 提出的一种修改意见是选择确认，它允许 TCP 接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段，从这个角度看 TCP 又像 SR 协议。**因此 TCP 的差错恢复机制是一种 GBN 和 SR  的结合体**。

除此之外，TCP 还使用**流量控制**和**拥塞控制**来保证可靠性。

1. 滑动窗口

2. 流量控制

   > TCP 通过让**发送方维护一个接收窗口的变量**来提供流量控制。通俗地说，接收窗口用于给发送方一个指示，该接收方还有多少可用的缓存空间，因此方法方的发送窗口不能超过接收方给出的接收窗口的数值。**因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口**。
   >
   > 
   >
   > 当接收窗口 rwnd 减小到 0 时，就不再允许发送方发送数据了。但是可能存在一种情况，当发生了零窗口报文段不久后，发送方的接收缓存又有了一些存储空间，因此又发生了新的报文说明自己的接收窗口大小，但是这个报文可能会在传输过程中丢失。接收方就会一直等待发送方的非零窗口通知，而发送方也一直在等待接收方发送数组，形成**一种死锁的状态**。为了解决这个问题，TCP 为每一个连接设有一个**0容量窗口持续计时器**，只要 TCP 连接的一方收到对方的零窗口通知就启动该计时器，到期后发送一个零窗口探测报文，如果仍为 0 就重新设置计时器的时间，如果对方给出了新的窗口值就可以解决可能出现的死锁问题。

3. 拥塞控制

   > 网络中对资源需求超过了资源可用量的情况就叫做拥塞。**拥塞控制是一个全局性的问题，它涉及网络中的所有路由器和主机，而流量控制只是一个端到端的问题，是两个端点之间通信量的控制。**
   >
   > 
   >
   > TCP 的拥塞控制算法主要包括了**慢启动**、**拥塞避免**和**快恢复**。慢启动和拥塞避免是 TCP 的强制部分，差异在于对收到的 ACK 做出反应时 cwnd 增加的方式，慢启动比拥塞避免要更快地增加 cwnd 的长度。快恢复是推荐部分，对 TCP 发送方不是必需的。
   >
   > 1. 慢启动
   >
   >    - 每经过一个 RTT 往返时间，**拥塞窗口就会翻倍，发送速率也会翻倍**。因此 TCP 的发送速率起始很慢，但是在慢启动阶段以指数增长。
   >    - ① 如果存在一个超时指示的丢包事件，即发生了拥塞，TCP 发送方就会**将 cwnd 设置为 1 并重新开始**慢启动过程。它还将慢启动阈值设置为 cwnd/2，即**检测到拥塞时将慢启动阈值设置为拥塞窗口的一半**。② 当拥塞窗口**达到慢启动阈值时就会结束慢启动而进入拥塞避免模式**。
   >
   > 2. 用塞避免
   >
   >    - 一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时的值的一半，每个 RTT 后只将 cwnd 的值增加一个 MSS。
   >
   > 3. 快恢复
   >
   >    - 有时候个报文段丢失，而网络中并没有出现拥塞，如果使用慢启动算法就会降低传输效率。这时应该使用快重传来让发送方尽早知道出现了个别分组的丢失，快重传要求接收端不要等待自己发送数据时再捎带确认，而是要立即发送确认。即使收到了乱序的报文段后也要立即发出对已收到报文段的重复确认。当发送方连续收到三个冗余 ACK 后就知道出现了报文段丢失的情况，会立即重传并进入快恢复状态。
   >
   >      在快恢复中，会**调整慢启动阈值为 cwnd 的一半，并进入拥塞避免状态。**

### TCP连接释放机制

1. 三次握手

   > 流程：
   >
   > 1.  A 发送数据时就向B发送一个连接请求报文，TCP 规定连接请求报文的 **SYN=1，ACK=0**，SYN不可以携带数据，但要消耗一个序号，假设此时 A 发送的序号 seq 为 x。发送完之后 A 就进入了 SYN-SENT 同步已发送状态。
   > 2. B 收到 A 的连接请求报文后，如果同意建立连接就会发送给 A 一个确认连接请求报文，其中 SYN=1，ACK=1，ack=x+1，seq=y，**ack 的值为 A 发送的序号加 1**，ACK 可以携带数据，如果不携带的话则不消耗序号。发送完之后，B进入 SYN-RCVD 同步已接收状态。
   > 3. A 收到 B 的确认连接请求报文后，还要对该确认再进行一次确认，报文的 ACK=1，ack=y+1，seq=x+1，发送后 A 进入 ESTABLISHED 状态，当 B 接收到该报文后也进入 ESTABLISHED 状态，客户端会稍早于服务器端建立连接。
   >
   > 原因：**信息对等和防止超时**
   >
   > - 防止失效连接突然到达导致脏连接，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据。如果是两次握手，连接已经建立了，服务器资源被白白浪费。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。
   >
   > 

2. 四次挥手

   > 流程：
   >
   > 1.  A 已经没有要发送的数据时就会释放连接，会向 B 发送一个终止连接报文，其中 FIN=1，seq=u，u 的值为之前 A 发送的最后一个序号+1。发送完之后进入 FIN-WAIT-1 状态。
   > 2. B 收到该报文后，发送给 A 一个确认报文，ACK=1，ack=u+1，seq=v，v 的值为 B 之前发送的最后一个序号+1。此时 A 进入了FIN-WAIT-2 状态，B 进入了 CLOSE-WAIT 状态，但连接并未完全释放，B 会通知高层的应用层结束 A 到 B 方向的连接，此时 TCP 处于半关闭状态。
   > 3. B 发送完数据后准备释放连接时，就向 A 发送连接终止报文，FIN=1，同时还要重发ACK=1，ack=u+1，seq=w，seq 不是 v 的原因是在半关闭状态 B 可能又发送了一些数据，之后 B 进入 LAST-ACK 状态。
   > 4. A 收到连接终止报文后还要再进行一次确认，确认报文中 ACK=1，ack=w+1，seq=u+1。发送完之后进入 TIME-WAIT 状态，**等待 2MSL之后进入 CLOSED 状态**，B 收到该确认后进入 CLOSED 状态，服务器端会稍早于客户端释放连接。
   >
   > 原因：
   >
   > 1. 保证被动关闭方可以进入 CLOSED 状态。MSL 是最大报文段寿命，**等待 2MSL 可以保证 A 发送的最后一个确认报文能被 B 接收**，如果该报文丢失，B 没有收到就会超时重传之前的 FIN+ACK 报文，而如果 A 在发送确认报文后就立即释放连接就无法收到 B 超时重传的报文，因而也不会再一次发送确认报文段，B 就无法正常进入 CLOSED 状态。
   > 2. 2MSL 时间之后，本连接中的所有报文就都会从网络中消失，可以**防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常**。
   
   

### TCP的缺陷与改进

TCP在传统的网络上工作的非常好，只是因为一些新的网络状况导致TCP不能很好的适应，这些就是需要改进的方向。

1. 流控算法不能很好的适应**高带宽高延迟**的场景，因为ack确认因为传输延迟不能及时送达导致传输速度远低于理论的传输带宽。
2. 拥塞控制算法也不能很好的适应**网络不太稳定**的场景（比如无线网络），TCP的拥塞控制认为丢包是因为网络传输饱和，所以一但出现丢包就采取指数级避让，而无线网络因为短暂的信号干扰导致的丢包并不是因为网络传输饱和，此时采取指数级避让是不合适的，会导致无线传输的速度骤降。

改进：BBR算法



### TCp与UDP区别

1） TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。
2） TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。
3） TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。
4） TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。



### HTTP与HTTP区别

1. http是超文本传输协议，信息是**明文传输**，https则是具有安全性的**ssl加密传输协议**。
2. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
3. http的连接很简单，是**无状态**的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

HTTPS的好处：

1. 防止重放攻击
2. 双向身份认证保证消息双方的合法性
3. 增加了中间人攻击的成本

HTTPS原理：

1. 客户端想服务端发起SSL请求（附带客户端支持的加密算法和产生秘钥的随机数）
2. 服务端选择算法，返回证书给客户端（包含服务器公钥）
3. 客户端检查服务端证书合法性（数字签名）
4. 客户端根据随机数计算私钥后返回给服务端

SSL认证流程：

1. 客户端向服务端发送消息
2. 服务端返回生成主密钥信息
3. 客户端生成主密钥，用服务器公钥加密后传输给服务器
4. 服务器返回用主密钥认证的消息